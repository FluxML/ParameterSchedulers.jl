[{"body":"public   Inv   —   parametric type A decay schedule that inversely decays with rate  γ . The output conforms to","id":"docstrings/ParameterSchedulers.Inv.html"},{"body":"Stateful iteration with training Sometimes zipping up the schedule with an iterator isn ’ t sufficient .  For example, we might want to advance the schedule with every batch but not be forced to restart each epoch .  In such a situation with nested loops, it becomes useful to use  ScheduleIterator  which maintains its own iteration state .","id":"docs/tutorials/optimizers.html#stateful-iteration-with-training"},{"body":"public   SinExp   —   parametric type A sine wave schedule with  period  and an exponentially decaying amplitude . The output conforms to where  Sin(t)  is the  cycle  of  Sin .","id":"docstrings/ParameterSchedulers.SinExp.html"},{"body":"Arguments λ0::Number : the start value λ1::Number : the end value period::Integer : the period","id":"docstrings/ParameterSchedulers.Cos.html#arguments"},{"body":"public   Sin   —   parametric type A sine wave schedule with  period . The output conforms to","id":"docstrings/ParameterSchedulers.Sin.html"},{"body":"private   cycle   —   function Concrete subtypes of  CyclicSchedule  must implement this function for  T . Given  s ,  cycle(s, t)  should return the value of the cycle function at iteration  t .","id":"docstrings/ParameterSchedulers.cycle.html"},{"body":"ParameterSchedulers Dev Build Status ParameterSchedulers . jl provides common machine learning (ML) schedulers for hyper - parameters .  Though this package is framework agnostic, a convenient interface for pairing schedules with  Flux . jl  optimizers is available .  Using this package with Flux is as simple as:","id":"README.html#parameterschedulers"},{"body":"public   TriExp   —   parametric type A  triangle wave  schedule with  period  and an exponentially decaying amplitude . The output conforms to where  Tri(t)  is the  cycle  of  Tri .","id":"docstrings/ParameterSchedulers.TriExp.html"},{"body":"private   startvalue   —   function Concrete subtypes of  CyclicSchedule  must implement this function for  T . Given  s , the function should return the start value of  s .","id":"docstrings/ParameterSchedulers.startvalue.html"},{"body":"Name Module Visibility Category  AbstractSchedule   ParameterSchedulers   private   type   Cos   ParameterSchedulers   public   parametric type   CyclicSchedule   ParameterSchedulers   private   type   DecaySchedule   ParameterSchedulers   private   type   Exp   ParameterSchedulers   public   parametric type   Inv   ParameterSchedulers   public   parametric type   Lambda   ParameterSchedulers   public   parametric type   Loop   ParameterSchedulers   public   parametric type   Poly   ParameterSchedulers   public   parametric type   ScheduleIterator   ParameterSchedulers   public   parametric type   ScheduledOptim   ParameterSchedulers   public   parametric type   Sequence   ParameterSchedulers   public   parametric type   Sin   ParameterSchedulers   public   parametric type   SinDecay2   ParameterSchedulers   public   parametric type   SinExp   ParameterSchedulers   public   parametric type   Step   ParameterSchedulers   public   parametric type   Tri   ParameterSchedulers   public   parametric type   TriDecay2   ParameterSchedulers   public   parametric type   TriExp   ParameterSchedulers   public   parametric type   basevalue   ParameterSchedulers   private   function   cycle   ParameterSchedulers   private   function   decay   ParameterSchedulers   private   function   endvalue   ParameterSchedulers   private   function   next!   ParameterSchedulers   private   function   reset!   ParameterSchedulers   private   function   reverse   ParameterSchedulers   private   function   startvalue   ParameterSchedulers   private   function   symmetric   ParameterSchedulers   private   function ","id":"docstrings.html#docstring-index"},{"body":"Cyclic schedules A cyclic schedule exhibits periodic behavior, and it is described by the following formula: where   is the schedule output,   and   are the start and end values, and   is the cycle function .  Similar to the decay function, the cycle function is expected to be bounded between  , but this requirement is only suggested and not enforced . We can access the start value, end value, and evaluate the cycle function through a provided interface: As with decay schedules, you won ’ t use the interface above and rely on  getindex  and  iterate  for most use - cases . Tri  (used in the above example) is a type of cyclic schedule .  Below is a list of all the cyclic schedules implemented, and the parameters and cycle functions for each one . Schedule Parameters Cycle Function  Tri   λ0 ,  λ1 ,  period     TriDecay2   λ0 ,  λ1 ,  period     TriExp   λ0 ,  λ1 ,  period ,  γ     Sin   λ0 ,  λ1 ,  period     SinDecay2   λ0 ,  λ1 ,  period     SinExp   λ0 ,  λ1 ,  period ,  γ     Cos   λ0 ,  λ1 ,  period   ","id":"docs/tutorials/basic-schedules.html#cyclic-schedules"},{"body":"Iterating during training Since every schedule is a standard iterator, we can insert it into a training loop by simply zipping up with another iterator .  For example, the following code adjusts the learning rate of the optimizer before each batch of training . We can also adjust the learning on an epoch basis instead .  All that is required is to change what we zip our schedule with .","id":"docs/tutorials/optimizers.html#iterating-during-training"},{"body":"public   Lambda   —   parametric type Wrap an arbitrary function  f  into a schedule . The schedule output at iteration  t  is  f(t) .","id":"docstrings/ParameterSchedulers.Lambda.html"},{"body":"public   Poly   —   parametric type A polynomial schedule decays with degree  p . The output conforms to","id":"docstrings/ParameterSchedulers.Poly.html"},{"body":"Arguments: λ::Number : the base value γ::Number : the decay rate step_sizes::Union{<:Integer, <:Vector} : the step sizes","id":"docstrings/ParameterSchedulers.Step.html#arguments"},{"body":"Complex schedules While the  basic schedules  tutorial covered the simple decay and cyclic schedules available in ParameterSchedulers . jl, it is possible to more complex schedules for added flexibility .","id":"docs/tutorials/complex-schedules.html#complex-schedules"},{"body":"Arbitrary functions Sometimes, a simple function is the easiest way to specify a schedule .  Similar to PyTorch ’ s  LambdaLR , ParameterSchedulers . jl provides  Lambda .  Unlike the decay or cyclic schedules that conform to a formula,  Lambda  simply wraps a given function,  f , and the schedule output is  f(t) .  But, unlike like  f  alone,  Lambda  can be indexed and iterated like all schedules .  Below, we wrap a logarithmic function as a schedule .","id":"docs/tutorials/complex-schedules.html#arbitrary-functions"},{"body":"private   CyclicSchedule   —   type An abstract type for all cyclic schedules . Such schedules conform to a formula: where  s(t)  is the schedule output,  λ0  is the start value, λ1  is the end value, and  g(t)  is the cycle function . Concrete subtypes must implment  startvalue ,  endvalue  and  cycle .","id":"docstrings/ParameterSchedulers.CyclicSchedule.html"},{"body":"Arguments: λ::Number : the base value γ::Number : the decay rate","id":"docstrings/ParameterSchedulers.Exp.html#arguments"},{"body":"private   reset!   —   function Reset  iter  to its initial state . See also  ScheduleIterator","id":"docstrings/ParameterSchedulers.reset!.html"},{"body":"Arguments λ::Number : the base value p::Integer : the degree of the polynomial max_iter::Integer : the total number of iterations","id":"docstrings/ParameterSchedulers.Poly.html#arguments"},{"body":"public   TriDecay2   —   parametric type A  triangle wave  schedule with  period  and half the amplitude each cycle . The output conforms to where  Tri(t)  is the  cycle  of  Tri .","id":"docstrings/ParameterSchedulers.TriDecay2.html"},{"body":"public   Cos   —   parametric type A cosine wave schedule with  period . The output conforms to","id":"docstrings/ParameterSchedulers.Cos.html"},{"body":"private   endvalue   —   function Concrete subtypes of  CyclicSchedule  must implement this function for  T . Given  s , the function should return the end value of  s .","id":"docstrings/ParameterSchedulers.endvalue.html"},{"body":"Decay interface Decay schedules conform to the following definition: where   is the schedule output,   is the base (initial) value, and   is the decay function .  Typically, the decay function is expected to be bounded between  , but this requirement is only suggested and not enforced . Unlike the  generic interface , the  decay interface  uses the formula above to abstract away most of the iteration and  Base.index  requirements .  Instead, a simple interface exists for defining the components of the formula .  The required functions and their descriptions are given below . Function Description  basevalue(s::DecaySchedule)  Return the base value,    decay(s::DecaySchedule, t)  Evaluate the decay function,   Next, we will implement a  Decay2  schedule that halves the parameter value every iteration .  First, we define the struct and inherit from  DecaySchedule . After this, we can define the interface functions .  Our decay function will be defined as  . Additionally, we can define parts of the iteration interface that cannot be inferred from the formula at the start .  These are optional, but they can be helpful for improving performance .  In this case, the schedule is an infinite iterator that returns the same type as  λ . Now, we can use  Decay2  schedule like any other decay schedule .  Below, sequence two different  Decay2  schedules . Sometimes, it is helpful to override the default iteration behavior for decay schedules .  Look at  Step  for an example for this .","id":"docs/interfaces/decay.html#decay-interface"},{"body":"Cyclic interface A cyclic schedule conforms to the formula where   is the schedule output,   and   are the start and end values, and   is the cycle function .  The cycle function is expected to be bounded between  , but this requirement is only suggested and not enforced . Unlike the  generic interface , the  cyclic interface  uses the formula above to abstract away most of the iteration and  Base.index  requirements .  Instead, a simple interface exists for defining the components of the formula .  The required functions and their descriptions are given below . Function Description  startvalue(s::CyclicSchedule)  Return the start value,    endvalue(s::CyclicSchedule)  Return the end value,    cycle(s::CyclicSchedule, t)  Evaluate the cycle function,   Below, we ’ ll use this interface to implement a new cyclic schedule,  Square , which implements a  square wave .  We start by inheriting from  CyclicSchedule . Now, we implement the interface .  The cycle function,  , will return 1 for the first  period / 2  steps, then 0 for the next . Additionally, we can define parts of the iteration interface that cannot be inferred from the formula at the start .  These are optional, but they can be helpful for improving performance .  In this case, the schedule is an infinite iterator that returns the same type as  λ0  or  λ1 . Square  is ready to use like any other schedule . Sometimes, it is helpful to override the default iteration behavior for cyclic schedules .  Look at  Step  for an example for this .","id":"docs/interfaces/cyclic.html#cyclic-interface"},{"body":"Arguments λ0::Number : the start value λ1::Number : the end value period::Integer : the period","id":"docstrings/ParameterSchedulers.Tri.html#arguments"},{"body":"public   Loop   —   parametric type Create a schedule that loops  f  every  period  iterations . Note that  f  must be a subtype of  AbstractSchedule . To loop arbitrary functions, wrap them in  Lambda .","id":"docstrings/ParameterSchedulers.Loop.html"},{"body":"public   Tri   —   parametric type A  triangle wave  schedule with  period . The output conforms to","id":"docstrings/ParameterSchedulers.Tri.html"},{"body":"Arguments schedule::AbstractSchedule : the schedule to use opt : a Flux optimizer update_func : a mutating function of with inputs  (optim, param) that updates  optim  based on the current  param  value","id":"docstrings/ParameterSchedulers.ScheduledOptim.html#arguments"},{"body":"Arguments λ0::Number : the start value λ1::Number : the end value period::Integer : the period γ::Number : the decay rate","id":"docstrings/ParameterSchedulers.TriExp.html#arguments"},{"body":"Basic schedules While ParameterSchedulers . jl has some complex scheduling capability, its core is made of two types of basic schedules:  decay schedules  and  cyclic schedules .  Each type of schedule conforms to an interface and formula which is relevant for understanding the schedules behavior, but more importantly, for creating your own custom schedules .  Still, both types of schedules can be indexed and iterated like we saw in the  getting started  tutorial .","id":"docs/tutorials/basic-schedules.html#basic-schedules"},{"body":"public   ScheduleIterator   —   parametric type Create a stateful iterator around  schedule . See also  next!  and  reset!","id":"docstrings/ParameterSchedulers.ScheduleIterator.html"},{"body":"public   Step   —   parametric type A step schedule decays exponentially by  γ  every step in  step_sizes . The output conforms to where  sum(step_sizes[1:(i - 1)]) < t <= sum(step_sizes[1:i])","id":"docstrings/ParameterSchedulers.Step.html"},{"body":"private   next!   —   function Advance  iter  by one iteration and return the next value . See also  ScheduleIterator","id":"docstrings/ParameterSchedulers.next!.html"},{"body":"private   reverse   —   function Return a reverse function such that  reverse(f, period)(t) == f(period - t) .","id":"docstrings/ParameterSchedulers.reverse.html"},{"body":"public   Sequence   —   parametric type A sequence of schedules . The output of this schedule is the concatenation of  schedules  where each schedule is evaluated for each step size in  step_sizes . Note that  schedules  can also be a vector of numbers (not just schedules) .","id":"docstrings/ParameterSchedulers.Sequence.html"},{"body":"Arguments λ0::Number : the start value λ1::Number : the end value period::Integer : the period","id":"docstrings/ParameterSchedulers.TriDecay2.html#arguments"},{"body":"Scheduling optimizers A schedule by itself is not helpful; we need to use the schedules to adjust parameters .  In this tutorial, we will examine three ways to do just that  —  iterating the schedule, using a stateful iterator, and using an scheduled optimizer .","id":"docs/tutorials/optimizers.html#scheduling-optimizers"},{"body":"Arguments schedules::AbstractVector : a vector of schedules or numbers step_sizes::Vector{<:Integer} : a vector of iteration lengths for each schedule","id":"docstrings/ParameterSchedulers.Sequence.html#arguments"},{"body":"Generic interface All schedules must inherit from  AbstractSchedule .  Any concrete subtype must implement the  iteration interface  and  Base.getindex .  Below we reimplement  Lambda  to illustrate what is required for another generic custom schedule . To avoid a name conflict, we will call our custom schedule  FooSchedule .  Let ’ s start with defining the struct . Next we implement the necessary interfaces .  The easiest implementation to define  Base.getindex , then rely on that to define the iteration behavior . By default,  Base.firstindex(s::AbstractSchedule) == 1 .  This behavior is expected across ParameterSchedulers . jl, so your definition of  Base.getindex  should conform to that . Sometimes, it might be more efficient to define  Base.iterate  separately from  Base.getindex .  See  Step  for an example what this might look like . Apart to the behavioral methods, there are some additional functions in the iteration interface left to define . In this case, the element type and length of the iterator is unknown, since  f  is unknown .  But you can define more restricted return values for your iterator . Once you are done defining the above interfaces, you can start using  FooSchedule  like any other schedule .  For example, below we create a  Loop  where the interval is defined as a  FooSchedule","id":"docs/interfaces/generic.html#generic-interface"},{"body":"private   decay   —   function Concrete subtypes of  DecaySchedule  must implement this function for  T . Given  s ,  decay(s, t)  should return the value of the decay function at iteration  t .","id":"docstrings/ParameterSchedulers.decay.html"},{"body":"private   basevalue   —   function Concrete subtypes of  DecaySchedule  must implement this function for  T . Given  s , the function should return the base value of  s .","id":"docstrings/ParameterSchedulers.basevalue.html"},{"body":"Available Schedules This is a table of the common schedules implemented, but ParameterSchedulers provides utilities for creating more exotic schedules as well .  You can read  this paper  for more information on the schedules below . Step(;λ, γ, step_sizes) Exponential decay by  γ  every step in  step_sizes Exp(;λ, γ) Exponential decay by  γ  every iteration Poly(;λ, p, max_iter) Polynomial decay at degree  p Inv(;λ, γ, p) Inverse decay at rate  (1 + tγ)^p Tri(;λ0, λ1, period) Triangle wave  function TriDecay2(;λ0, λ1, period) Triangle wave  function with half the amplitude every  period TriExp(;λ0, λ1, period, γ) Triangle wave  function with exponential amplitude decay at rate  γ Sin(;λ0, λ1, period) Sine function SinDecay2(;λ0, λ1, period) Sine function with half the amplitude every  period SinExp(;λ0, λ1, period) Sine function with exponential amplitude decay at rate  γ Cos(;λ0, λ1, period) Cosine function","id":"README.html#available-schedules"},{"body":"private   symmetric   —   function Return a symmetric function such that for  t ∈ [1, period / 2) , the symmetric function evaluates to  f(t) , and when  t ∈ [period / 2, period) , the symmetric functions evaluates to  f(period - t) .","id":"docstrings/ParameterSchedulers.symmetric.html"},{"body":"Arguments λ0::Number : the start value λ1::Number : the end value period::Integer : the period","id":"docstrings/ParameterSchedulers.SinDecay2.html#arguments"},{"body":"Arguments λ0::Number : the start value λ1::Number : the end value period::Integer : the period γ::Number : the decay rate","id":"docstrings/ParameterSchedulers.SinExp.html#arguments"},{"body":"Arguments λ0::Number : the start value λ1::Number : the end value period::Integer : the period","id":"docstrings/ParameterSchedulers.Sin.html#arguments"},{"body":"public   Exp   —   parametric type A exponential decay schedule at rate  γ . The output conforms to","id":"docstrings/ParameterSchedulers.Exp.html"},{"body":"public   ScheduledOptim   —   parametric type Wrap a  schedule  and  opt  together into a  ScheduledOptim . The  schedule  is iterated on every call to Flux.apply! . The  ScheduledOptim  can be used anywhere a Flux optimizer is used . The keyword argument constructor sets  update_func(opt, s) to schedule the learning rate of  opt  to  s  on every iteration . You can update any field of  opt  by passing your own  update_func . Instead of constructing  schedule  and  opt  separately, you can use the  ::Type{<:AbstractSchedule}  constructor (e . g .   Exp  below):","id":"docstrings/ParameterSchedulers.ScheduledOptim.html"},{"body":"Sequences of schedules Finally, we might concatenate sequences of schedules, applying each one for a given length, then switch to the next schedule in the order .  A  Sequence  schedule lets us do this .  For example, we can start with a cyclic schedule, then switch to a more conservative exponential schedule half way through training . Alternatively, we might simply wish to manually set the parameter every interval .   Sequence  also accepts a vector of numbers .","id":"docs/tutorials/complex-schedules.html#sequences-of-schedules"},{"body":"Arbitrary looping schedules Let ’ s take the notion of  Lambda  one step further, and instead define how a schedule behaves over a given interval or period .  Then, we would like to loop that interval over and over .  This is precisely what  Loop  achieves .  For example, we may want to apply an  Exp  schedule for 10 iterations, then repeat from the beginning, and so forth .","id":"docs/tutorials/complex-schedules.html#arbitrary-looping-schedules"},{"body":"Getting started All schedules types in ParameterSchedulers . jl behave as indexable iterators .  For example, we can index the simple exponential decay schedule ( Exp ) below: The indices are unitless .  So, if you index a schedule every epoch, then the  s[i]  is parameter value at epoch  i . We can also use the schedule in an iterable context like a  for - loop: Many schedules such as  Exp  are infinite iterators, so iterating over them will result in an infinite loop .  You can use  Base.IteratorSize  to check if a schedule has infinite length . Notice that the value of  s[1]  and  s[5]  is unchanged even though we accessed the schedule once via  getindex  and again in the  for - loop .  This is because all schedules in ParameterSchedulers . jl are  immutable .  If you want a stateful schedule, then you can use  ScheduleIterator : We used  ParameterSchedulers.next!  to advance the stateful iterator .  Notice that  stateful_s  stores a reference to  s  and the current iteration state (which is  3  since we advanced the iterator twice) .  Also note that  ScheduleIterator  cannot be indexed (or iterated with  Base.iterate ):","id":"docs/tutorials/getting-started.html#getting-started"},{"body":"Arguments λ::Number : the base value γ::Number : the decay rate p::Integer : the degree of decay","id":"docstrings/ParameterSchedulers.Inv.html#arguments"},{"body":"public   SinDecay2   —   parametric type A sine wave schedule with  period  and half the amplitude each cycle . The output conforms to where  Sin(t)  is the  cycle  of  Sin .","id":"docstrings/ParameterSchedulers.SinDecay2.html"},{"body":"Working with Flux optimizers Currently, we are porting  ScheduledOptim  to Flux . jl . It may be renamed once it is ported out of this package . While the approaches above can be helpful when dealing with fine - grained training loops, it is usually simpler to just use a  ScheduledOptim . The scheduled optimizer,  opt , can be used anywhere a Flux optimizer can .  For example, it can be passed to  Flux.train! .","id":"docs/tutorials/optimizers.html#working-with-flux-optimizers"},{"body":"Decay schedules A decay schedule is defined by the following formula: where   is the schedule output,   is the base (initial) value, and   is the decay function .  Typically, the decay function is expected to be bounded between  , but this requirement is only suggested and not enforced . We can access the base value and evaluate the decay function through a provided interface: In most situations, you won ’ t use the interface above and rely on  getindex  or  iterate  instead . As you can see above,  Exp  is a type of decay schedule .  Below is a list of all the decay schedules implemented, and the parameters and decay functions for each one . Schedule Parameters Decay Function  Step   λ ,  γ ,  step_sizes    where    Exp   λ ,  γ     Poly   λ ,  p ,  max_iter     Inv   λ ,  γ ,  p   ","id":"docs/tutorials/basic-schedules.html#decay-schedules"},{"body":"private   AbstractSchedule   —   type All schedules should inherit from this type or its subtypes . Concrete subtypes are expected to conform to the iteration interface and implement  Base.getindex .","id":"docstrings/ParameterSchedulers.AbstractSchedule.html"},{"body":"private   DecaySchedule   —   type An abstract type for all decay schedules . Such schedules conform to a formula: where  s(t)  is the schedule output,  λ  is the base value, and  g(t)  is the decay function . Concrete subtypes must implment  basevalue  and  decay .","id":"docstrings/ParameterSchedulers.DecaySchedule.html"},{"body":"Arguments f::AbstractSchedule : the schedule to loop period::Integer : how often to loop","id":"docstrings/ParameterSchedulers.Loop.html#arguments"}]