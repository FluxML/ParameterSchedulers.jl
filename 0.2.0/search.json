[{"body":"public   Inv   —   parametric type A decay schedule that inversely decays with rate  γ . The output conforms to","id":"docstrings/ParameterSchedulers.Inv.html"},{"body":"Decay by half We will implement a  Decay2  schedule that halves the parameter value every iteration .  First, we define the struct . After this, we can define the interface functions .  Our decay function will be defined as  . Now, we can use  Decay2  schedule like any other decay schedule .  Below, sequence two different  Decay2  schedules .","id":"docs/interfaces/generic.html#decay-by-half"},{"body":"Stateful iteration with training Sometimes zipping up the schedule with an iterator isn ’ t sufficient .  For example, we might want to advance the schedule with every batch but not be forced to restart each epoch .  In such a situation with nested loops, it becomes useful to use  ParameterSchedulers.Stateful  which maintains its own iteration state .","id":"docs/tutorials/optimizers.html#stateful-iteration-with-training"},{"body":"public   SinExp   —   parametric type A sine wave schedule with  period  and an exponentially decaying amplitude . The output conforms to where  Sin(t)  is  abs(sin(π * (t - 1) / period))  (see  Sin ) .","id":"docstrings/ParameterSchedulers.SinExp.html"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period","id":"docstrings/ParameterSchedulers.Cos.html#arguments"},{"body":"public   TriangleDecay2   —   parametric type A  triangle wave  schedule with  period  and half the amplitude each cycle . The output conforms to where  Triangle(t)  is  (2 / π) * abs(asin(sin(π * (t - 1) / schedule.period)))  (see  Triangle ) .","id":"docstrings/ParameterSchedulers.TriangleDecay2.html"},{"body":"public   Sin   —   parametric type A sine wave schedule with  period . The output conforms to","id":"docstrings/ParameterSchedulers.Sin.html"},{"body":"ParameterSchedulers Dev Build Status ParameterSchedulers . jl provides common machine learning (ML) schedulers for hyper - parameters .  Though this package is framework agnostic, a convenient interface for pairing schedules with  Flux . jl  optimizers is available .  Using this package with Flux is as simple as:","id":"README.html#parameterschedulers"},{"body":"Name Module Visibility Category  Cos   ParameterSchedulers   public   parametric type   Exp   ParameterSchedulers   public   parametric type   Inv   ParameterSchedulers   public   parametric type   Loop   ParameterSchedulers   public   parametric type   Poly   ParameterSchedulers   public   parametric type   Scheduler   ParameterSchedulers   private   parametric type   Sequence   ParameterSchedulers   public   parametric type   Sin   ParameterSchedulers   public   parametric type   SinDecay2   ParameterSchedulers   public   parametric type   SinExp   ParameterSchedulers   public   parametric type   Stateful   ParameterSchedulers   private   parametric type   Step   ParameterSchedulers   public   parametric type   Triangle   ParameterSchedulers   public   parametric type   TriangleDecay2   ParameterSchedulers   public   parametric type   TriangleExp   ParameterSchedulers   public   parametric type   next!   ParameterSchedulers   private   function   reset!   ParameterSchedulers   private   function   reverse   ParameterSchedulers   private   function   symmetric   ParameterSchedulers   private   function ","id":"docstrings.html#docstring-index"},{"body":"private   Scheduler   —   parametric type Wrap a  schedule  and  opt  together with a  Scheduler . The  schedule  is iterated on every call to Flux.apply! . The  Scheduler  can be used anywhere a Flux optimizer is used . By default, the learning rate (i . e .   opt.eta ) is scheduled . Set  update_func = (opt, schedule_val) -> ...  to schedule an alternate field . If  opt  does not have a field  eta , then there is no default behavior (you must manually set  update_func ) .","id":"docstrings/ParameterSchedulers.Scheduler.html"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period decay / γ : the decay rate","id":"docstrings/ParameterSchedulers.TriangleExp.html#arguments"},{"body":"Cyclic schedules A cyclic schedule exhibits periodic behavior, and it is described by the following formula: where   is the schedule output,   and   are the range endpoints, and   is the cycle function .  Similar to the decay function, the cycle function is expected to be bounded between  , but this requirement is only suggested and not enforced . For example, here is triangular wave schedule: Tri  (used in the above example) is a type of cyclic schedule .  Below is a list of all the cyclic schedules implemented, and the parameters and cycle functions for each one . Schedule Parameters Cycle Function  Tri   λ0 ,  λ1 ,  period     TriDecay2   λ0 ,  λ1 ,  period     TriExp   λ0 ,  λ1 ,  period ,  γ     Sin   λ0 ,  λ1 ,  period     SinDecay2   λ0 ,  λ1 ,  period     SinExp   λ0 ,  λ1 ,  period ,  γ     Cos   λ0 ,  λ1 ,  period   ","id":"docs/tutorials/basic-schedules.html#cyclic-schedules"},{"body":"More examples Below, we implement two more custom schedules that conform to the decay and cyclic defitions .  The interface is no different than  Lambda  above .","id":"docs/interfaces/generic.html#more-examples"},{"body":"Iterating during training Since every schedule is a standard iterator, we can insert it into a training loop by simply zipping up with another iterator .  For example, the following code adjusts the learning rate of the optimizer before each batch of training . We can also adjust the learning on an epoch basis instead .  All that is required is to change what we zip our schedule with .","id":"docs/tutorials/optimizers.html#iterating-during-training"},{"body":"public   Triangle   —   parametric type A  triangle wave  schedule with  period . The output conforms to","id":"docstrings/ParameterSchedulers.Triangle.html"},{"body":"Arguments: start / λ : the starting value decay / γ : the decay rate step_sizes::Union{<:Integer, <:Vector} : the step sizes","id":"docstrings/ParameterSchedulers.Step.html#arguments"},{"body":"public   Poly   —   parametric type A polynomial schedule decays with degree  p . The output conforms to","id":"docstrings/ParameterSchedulers.Poly.html"},{"body":"A square wave schedule Now, we ’ ll use the interface to implement a new cyclic schedule,  Square , which implements a  square wave . Now, we implement the interface .  The cycle function,  , will return  λ1  for the first  period / 2  steps, then  λ0  for the next . Square  is ready to use like any other schedule .","id":"docs/interfaces/generic.html#a-square-wave-schedule"},{"body":"Complex schedules While the  basic schedules  tutorial covered the simple decay and cyclic schedules available in ParameterSchedulers . jl, it is possible to more complex schedules for added flexibility .","id":"docs/tutorials/complex-schedules.html#complex-schedules"},{"body":"Arbitrary functions Sometimes, a simple function is the easiest way to specify a schedule .  Unlike PyTorch ’ s  LambdaLR , ParameterSchedulers . jl allows you to use the function directly .  The schedule output is  f(t) .  While you can use  f  directly to build up complex schedules (as we ’ ll see in the next section), it lacks functionality like  Base.iterate .  If you want  f  to behave more formally like a schedule, implement the  generic interface  for schedules .","id":"docs/tutorials/complex-schedules.html#arbitrary-functions"},{"body":"Arguments: start / λ : the base value decay / γ : the decay rate","id":"docstrings/ParameterSchedulers.Exp.html#arguments"},{"body":"private   reset!   —   function Reset  iter  to its initial state . See also  ParameterSchedulers.Stateful .","id":"docstrings/ParameterSchedulers.reset!.html"},{"body":"Arguments start / λ : the base value degree / p::Integer : the degree of the polynomial max_iter::Integer : the total number of iterations","id":"docstrings/ParameterSchedulers.Poly.html#arguments"},{"body":"public   TriangleExp   —   parametric type A  triangle wave  schedule with  period  and an exponentially decaying amplitude . The output conforms to where  Triangle(t)  is  (2 / π) * abs(asin(sin(π * (t - 1) / schedule.period)))  (see  Triangle ) .","id":"docstrings/ParameterSchedulers.TriangleExp.html"},{"body":"public   Cos   —   parametric type A cosine wave schedule with  period . The output conforms to This schedule is also referred to as  “ cosine annealing ”  or “ cosine annealing with warm restarts ”  in machine learning literature .","id":"docstrings/ParameterSchedulers.Cos.html"},{"body":"public   Loop   —   parametric type Create a schedule that loops  f  every  period  iterations . f  must be callabe (a function or schedule) .","id":"docstrings/ParameterSchedulers.Loop.html"},{"body":"Arguments schedule : the schedule to use opt : a Flux optimizer update_func : a mutating function of with inputs  (optim, param) that mutates  optim ’ s fields based on the current  param  value","id":"docstrings/ParameterSchedulers.Scheduler.html#arguments"},{"body":"Basic schedules While ParameterSchedulers . jl has some complex scheduling capability, its core is made of two kinds of basic schedules:  decay schedules  and  cyclic schedules .  Each kind of schedule conforms to a formula which is relevant for understanding the schedules behavior .  Still, both types of schedules can be called and iterated like we saw in the  getting started  tutorial .","id":"docs/tutorials/basic-schedules.html#basic-schedules"},{"body":"public   Step   —   parametric type A step schedule decays exponentially by  γ  every step in  step_sizes . The output conforms to where  sum(step_sizes[1:(i - 1)]) < t <= sum(step_sizes[1:i])","id":"docstrings/ParameterSchedulers.Step.html"},{"body":"private   next!   —   function Advance  iter  by one iteration and return the next value . See also  ParameterSchedulers.Stateful .","id":"docstrings/ParameterSchedulers.next!.html"},{"body":"private   reverse   —   function Return a reverse function such that  reverse(f, period)(t) == f(period - t) .","id":"docstrings/ParameterSchedulers.reverse.html"},{"body":"public   Sequence   —   parametric type A sequence of schedules . The output of this schedule is the concatenation of  schedules  where each schedule is evaluated for each step size in  step_sizes . Note that  schedules  can also be a vector of numbers (not just schedules) .","id":"docstrings/ParameterSchedulers.Sequence.html"},{"body":"Scheduling optimizers A schedule by itself is not helpful; we need to use the schedules to adjust parameters .  In this tutorial, we will examine three ways to do just that  —  iterating the schedule, using a stateful iterator, and using an scheduled optimizer .","id":"docs/tutorials/optimizers.html#scheduling-optimizers"},{"body":"Generic interface All schedules must implement the interface  (s::MySchedule)(t)  which returns the schedule value at iteration  t .  Additionally, a schedule must implement the  iteration interface . Below we implement  Lambda  to illustrate what is required for a custom schedule .   Lambda  simply wraps a function,  f , and the schedule value at iteration  t  is  f(t) . Next we implement the necessary interfaces .  The easiest way to define  (s::Lambda)(t) , then rely on that to define the iteration behavior . Sometimes, it might be more efficient to define  Base.iterate  separately from  s(t) .  See  Step  for an example what this might look like . You can also define optional parts of the iteration interface if you choose .  They are not required for ParameterSchedulers . jl . Once you are done defining the above interfaces, you can start using  Lambda  like any other schedule .  For example, below we create a  Loop  where the interval is defined as a  Lambda","id":"docs/interfaces/generic.html#generic-interface"},{"body":"Arguments schedules : a vector of schedules or numbers step_sizes : a vector of iteration lengths for each schedule","id":"docstrings/ParameterSchedulers.Sequence.html#arguments"},{"body":"Available Schedules This is a table of the common schedules implemented, but ParameterSchedulers provides utilities for creating more exotic schedules as well .  You can read  this paper  for more information on the schedules below . Step(;λ, γ, step_sizes) Exponential decay by  γ  every step in  step_sizes Exp(;λ, γ) Exponential decay by  γ  every iteration Poly(;λ, p, max_iter) Polynomial decay at degree  p Inv(;λ, γ, p) Inverse decay at rate  (1 + tγ)^p Triangle(;λ0, λ1, period) Triangle wave  function TriangleDecay2(;λ0, λ1, period) Triangle wave  function with half the amplitude every  period TriangleExp(;λ0, λ1, period, γ) Triangle wave  function with exponential amplitude decay at rate  γ Sin(;λ0, λ1, period) Sine function SinDecay2(;λ0, λ1, period) Sine function with half the amplitude every  period SinExp(;λ0, λ1, period) Sine function with exponential amplitude decay at rate  γ Cos(;λ0, λ1, period) Cosine function","id":"README.html#available-schedules"},{"body":"private   symmetric   —   function Return a symmetric function such that for  t ∈ [1, period / 2) , the symmetric function evaluates to  f(t) , and when  t ∈ [period / 2, period) , the symmetric functions evaluates to  f(period - t) .","id":"docstrings/ParameterSchedulers.symmetric.html"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period","id":"docstrings/ParameterSchedulers.SinDecay2.html#arguments"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period decay / γ : the decay rate","id":"docstrings/ParameterSchedulers.SinExp.html#arguments"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period","id":"docstrings/ParameterSchedulers.Sin.html#arguments"},{"body":"public   Exp   —   parametric type A exponential decay schedule at rate  γ . The output conforms to","id":"docstrings/ParameterSchedulers.Exp.html"},{"body":"private   Stateful   —   parametric type Create a stateful iterator around  schedule . See also  ParameterSchedulers.next!  and  ParameterSchedulers.reset! .","id":"docstrings/ParameterSchedulers.Stateful.html"},{"body":"Sequences of schedules Finally, we might concatenate sequences of schedules, applying each one for a given length, then switch to the next schedule in the order .  A  Sequence  schedule lets us do this .  For example, we can start with a triangular schedule, then switch to a more conservative exponential schedule half way through training . Alternatively, we might simply wish to manually set the parameter every interval .   Sequence  also accepts a vector of numbers .","id":"docs/tutorials/complex-schedules.html#sequences-of-schedules"},{"body":"Examples","id":"docstrings/ParameterSchedulers.Scheduler.html#examples"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period","id":"docstrings/ParameterSchedulers.Triangle.html#arguments"},{"body":"Arbitrary looping schedules Let ’ s take the notion of arbitrary schedules one step further, and instead define how a schedule behaves over a given interval or period .  Then, we would like to loop that interval over and over .  This is precisely what  Loop  achieves .  For example, we may want to apply an  Exp  schedule for 10 iterations, then repeat from the beginning, and so forth . Or we can just an arbitrary function to loop (e . g .   log ) .","id":"docs/tutorials/complex-schedules.html#arbitrary-looping-schedules"},{"body":"Getting started All schedules types in ParameterSchedulers . jl behave as callable iterators .  For example, we can call the simple exponential decay schedule ( Exp ) below at a specific iteration: The iterations are unitless .  So, if you index a schedule every epoch, then the  s(i)  is parameter value at epoch  i . We can also use the schedule in an iterable context like a  for - loop: Many schedules such as  Exp  are infinite iterators, so iterating over them will result in an infinite loop .  You can use  Base.IteratorSize  to check if a schedule has infinite length . Notice that the value of  s(1)  and  s(5)  is unchanged even though we accessed the schedule once by calling them and again in the  for - loop .  This is because all schedules in ParameterSchedulers . jl are  immutable .  If you want a stateful (mutable) schedule, then you can use  ParameterSchedulers.Stateful : We used  ParameterSchedulers.next!  to advance the stateful iterator .  Notice that  stateful_s  stores a reference to  s  and the current iteration state (which is  3  since we advanced the iterator twice) .  We can reset the mutable iteration state too: Also note that  Stateful  cannot be called (or iterated with  Base.iterate ):","id":"docs/tutorials/getting-started.html#getting-started"},{"body":"Arguments start / λ : the base value decay / γ : the decay rate degree / p::Integer : the degree of decay","id":"docstrings/ParameterSchedulers.Inv.html#arguments"},{"body":"public   SinDecay2   —   parametric type A sine wave schedule with  period  and half the amplitude each cycle . The output conforms to where  Sin(t)  is  abs(sin(π * (t - 1) / period))  (see  Sin ) .","id":"docstrings/ParameterSchedulers.SinDecay2.html"},{"body":"Working with Flux optimizers Currently, we are porting  Scheduler  to Flux . jl . It may be renamed once it is ported out of this package . The API will also undergo minor changes . While the approaches above can be helpful when dealing with fine - grained training loops, it is usually simpler to just use a  ParameterSchedulers.Scheduler . The scheduler,  opt , can be used anywhere a Flux optimizer can .  For example, it can be passed to  Flux.train! :","id":"docs/tutorials/optimizers.html#working-with-flux-optimizers"},{"body":"Decay schedules A decay schedule is defined by the following formula: where   is the schedule output,   is the base (initial) value, and   is the decay function .  Typically, the decay function is expected to be bounded between  , but this requirement is only suggested and not enforced . For example, here is an exponential decay schedule: As you can see above,  Exp  is a type of decay schedule .  Below is a list of all the decay schedules implemented, and the parameters and decay functions for each one . Schedule Parameters Decay Function  Step   λ ,  γ ,  step_sizes    where    Exp   λ ,  γ     Poly   λ ,  p ,  max_iter     Inv   λ ,  γ ,  p   ","id":"docs/tutorials/basic-schedules.html#decay-schedules"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period","id":"docstrings/ParameterSchedulers.TriangleDecay2.html#arguments"},{"body":"Arguments f : the schedule to loop period::Integer : how often to loop","id":"docstrings/ParameterSchedulers.Loop.html#arguments"}]