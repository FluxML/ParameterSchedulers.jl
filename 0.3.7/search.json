[{"body":"public   Inv   —   parametric type A decay schedule that inversely decays with rate  γ . The output conforms to","id":"docstrings/ParameterSchedulers.Inv.html"},{"body":"Arguments range == abs(λ0 - λ1) : the dynamic range (given by the endpoints) offset == min(λ0, λ1) : the offset / minimum value period::Integer : the period restart::Bool : use warm - restarts","id":"docstrings/ParameterSchedulers.CosAnneal.html#arguments"},{"body":"Decay by half We will implement a  Decay2  schedule that halves the parameter value every iteration .  First, we define the struct . After this, we can define the interface functions .  Our decay function will be defined as  . Now, we can use  Decay2  schedule like any other decay schedule .  Below, sequence two different  Decay2  schedules .","id":"docs/interfaces/generic.html#decay-by-half"},{"body":"Stateful iteration with training Sometimes zipping up the schedule with an iterator isn ’ t sufficient .  For example, we might want to advance the schedule with every batch but not be forced to restart each epoch .  In such a situation with nested loops, it becomes useful to use  ParameterSchedulers.Stateful  which maintains its own iteration state .","id":"docs/tutorials/optimizers.html#stateful-iteration-with-training"},{"body":"public   SinExp   —   function A sine wave schedule with  period  and an exponentially decaying amplitude . The output conforms to where  Sin(t)  is  abs(sin(π * (t - 1) / period))  (see  Sin ) .","id":"docstrings/ParameterSchedulers.SinExp.html"},{"body":"public   TriangleDecay2   —   function A  triangle wave  schedule with  period  and half the amplitude each cycle . The output conforms to where  Triangle(t)  is  (2 / π) * abs(asin(sin(π * (t - 1) / schedule.period)))  (see  Triangle ) .","id":"docstrings/ParameterSchedulers.TriangleDecay2.html"},{"body":"private   Constant   —   parametric type A constant schedule that is always  value .","id":"docstrings/ParameterSchedulers.Constant.html"},{"body":"Linear ramp Suppose we want to increase our learning rate using a linear ramp function .  We can achieve this by running a  Triangle  schedule for a half - period . Of course, if we run the  Triangle  for more than  warmup  iterations, it will be periodic .  So, we want to make sure to start our  “ real ”  schedule immediately after half a period .","id":"docs/tutorials/warmup-schedules.html#linear-ramp"},{"body":"public   Sin   —   parametric type A sine wave schedule with  period . The output conforms to","id":"docstrings/ParameterSchedulers.Sin.html"},{"body":"ParameterSchedulers Dev Build Status ParameterSchedulers . jl provides common machine learning (ML) schedulers for hyper - parameters .  Though this package is framework agnostic, a convenient interface for pairing schedules with  Flux . jl  optimizers is available .  Using this package with Flux is as simple as:","id":"README.html#parameterschedulers"},{"body":"public   Interpolator   —   parametric type A schedule whose output is  schedule(t / rate)  (i . e .  it interpolates  schedule(t) ) . This can be useful when your code iterates over real numbers at a fixed rate (e . g .  in a fixed time step differential solver), but you want to use a schedule that iterates discretely over integers . It could also be used to specify  schedule  in units of epochs, while iterating it in units of mini - batches . Specify  ceil_fn  to apply a ceiling (or flooring) function to  t / rate .","id":"docstrings/ParameterSchedulers.Interpolator.html"},{"body":"public   Shifted   —   parametric type A  schedule  who ’ s starting iteration is shifted to  offset . (i . e .  calling an  Shifted  with  t = 1  is equivalent to calling schedule  with  t = offset )","id":"docstrings/ParameterSchedulers.Shifted.html"},{"body":"Name Module Visibility Category  AbstractSchedule   ParameterSchedulers   private   parametric type   ComposedSchedule   ParameterSchedulers   public   parametric type   Constant   ParameterSchedulers   private   parametric type   CosAnneal   ParameterSchedulers   public   parametric type   Exp   ParameterSchedulers   public   parametric type   Interpolator   ParameterSchedulers   public   parametric type   Inv   ParameterSchedulers   public   parametric type   Loop   ParameterSchedulers   public   parametric type   Poly   ParameterSchedulers   public   parametric type   Scheduler   ParameterSchedulers   private   parametric type   Sequence   ParameterSchedulers   public   parametric type   Shifted   ParameterSchedulers   public   parametric type   Sin   ParameterSchedulers   public   parametric type   SinDecay2   ParameterSchedulers   public   function   SinExp   ParameterSchedulers   public   function   Stateful   ParameterSchedulers   private   parametric type   Step   ParameterSchedulers   public   parametric type   Triangle   ParameterSchedulers   public   parametric type   TriangleDecay2   ParameterSchedulers   public   function   TriangleExp   ParameterSchedulers   public   function   next!   ParameterSchedulers   private   function   reset!   ParameterSchedulers   private   function   reverse   ParameterSchedulers   private   function   symmetric   ParameterSchedulers   private   function ","id":"docstrings.html#docstring-index"},{"body":"private   Scheduler   —   parametric type Wrap a  schedule  and  opt  together with a  Scheduler . The  schedule  is iterated on every call to Flux.apply! . The  Scheduler  can be used anywhere a Flux optimizer is used . By default, the learning rate (i . e .   opt.eta ) is scheduled . Set  update_func = (opt, schedule_val) -> ...  to schedule an alternate field . If  opt  does not have a field  eta , then there is no default behavior (you must manually set  update_func ) .","id":"docstrings/ParameterSchedulers.Scheduler.html"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period decay / γ : the decay rate","id":"docstrings/ParameterSchedulers.TriangleExp.html#arguments"},{"body":"Cyclic schedules A cyclic schedule exhibits periodic behavior, and it is described by the following formula: where   is the schedule output,   and   are the range endpoints, and   is the cycle function .  Similar to the decay function, the cycle function is expected to be bounded between  , but this requirement is only suggested and not enforced . For example, here is triangular wave schedule: Triangle  (used in the above example) is a type of cyclic schedule .  Below is a list of all the cyclic schedules implemented, and the parameters and cycle functions for each one . Schedule Parameters Cycle Function  Triangle   λ0 ,  λ1 ,  period     TriangleDecay2   λ0 ,  λ1 ,  period     TriangleExp   λ0 ,  λ1 ,  period ,  γ     Sin   λ0 ,  λ1 ,  period     SinDecay2   λ0 ,  λ1 ,  period     SinExp   λ0 ,  λ1 ,  period ,  γ     CosAnneal   λ0 ,  λ1 ,  period ,  restart == true     CosAnneal   λ0 ,  λ1 ,  period ,  restart == false   ","id":"docs/tutorials/basic-schedules.html#cyclic-schedules"},{"body":"Iterating during training Since every schedule is a standard iterator, we can insert it into a training loop by simply zipping up with another iterator .  For example, the following code adjusts the learning rate of the optimizer before each batch of training . We can also adjust the learning on an epoch basis instead .  All that is required is to change what we zip our schedule with .","id":"docs/tutorials/optimizers.html#iterating-during-training"},{"body":"public   Triangle   —   parametric type A  triangle wave  schedule with  period . The output conforms to","id":"docstrings/ParameterSchedulers.Triangle.html"},{"body":"Arguments: start / λ : the starting value decay / γ : the decay rate step_sizes::Union{<:Integer, <:Vector} : the step sizes","id":"docstrings/ParameterSchedulers.Step.html#arguments"},{"body":"public   Poly   —   parametric type A polynomial schedule decays with degree  p . The output conforms to","id":"docstrings/ParameterSchedulers.Poly.html"},{"body":"A square wave schedule Now, we ’ ll use the interface to implement a new cyclic schedule,  Square , which implements a  square wave . Now, we implement the interface .  The cycle function,  , will return  λ1  for the first  period / 2  steps, then  λ0  for the next . Square  is ready to use like any other schedule .","id":"docs/interfaces/generic.html#a-square-wave-schedule"},{"body":"Complex schedules While the  basic schedules  tutorial covered the simple decay and cyclic schedules available in ParameterSchedulers . jl, it is possible to more complex schedules for added flexibility .","id":"docs/tutorials/complex-schedules.html#complex-schedules"},{"body":"Arbitrary functions Sometimes, a simple function is the easiest way to specify a schedule .  Unlike PyTorch ’ s  LambdaLR , ParameterSchedulers . jl allows you to use the function directly .  The schedule output is  f(t) .  While you can use  f  directly to build up complex schedules (as we ’ ll see in the next section), it lacks functionality like  Base.iterate .  If you want  f  to behave more formally like a schedule, implement the  generic interface  for schedules .","id":"docs/tutorials/complex-schedules.html#arbitrary-functions"},{"body":"Arguments: start / λ : the base value decay / γ : the decay rate","id":"docstrings/ParameterSchedulers.Exp.html#arguments"},{"body":"private   reset!   —   function Reset  iter  to its initial state . See also  ParameterSchedulers.Stateful .","id":"docstrings/ParameterSchedulers.reset!.html"},{"body":"Examples","id":"docs/interfaces/generic.html#examples"},{"body":"Arguments start / λ : the base value degree / p::Integer : the degree of the polynomial max_iter::Integer : the total number of iterations","id":"docstrings/ParameterSchedulers.Poly.html#arguments"},{"body":"public   TriangleExp   —   function A  triangle wave  schedule with  period  and an exponentially decaying amplitude . The output conforms to where  Triangle(t)  is  (2 / π) * abs(asin(sin(π * (t - 1) / schedule.period)))  (see  Triangle ) .","id":"docstrings/ParameterSchedulers.TriangleExp.html"},{"body":"Warm - up Schedules A popular technique for scheduling learning rates is  “ warming - up ”  the optimizer by ramping the learning rate up from zero to the  “ true ”  initial learning rate, then starting the  “ real ”  schedule .  This is easily implementable with ParameterSchedulers . jl using  Sequence .","id":"docs/tutorials/warmup-schedules.html#warm-up-schedules"},{"body":"public   Loop   —   parametric type Create a schedule that loops  f  every  period  iterations . f  must be callabe (a function or schedule) .","id":"docstrings/ParameterSchedulers.Loop.html"},{"body":"Arguments schedule : the schedule to use opt : a Flux optimizer update_func : a mutating function of with inputs  (optim, param) that mutates  optim ’ s fields based on the current  param  value","id":"docstrings/ParameterSchedulers.Scheduler.html#arguments"},{"body":"Basic schedules While ParameterSchedulers . jl has some complex scheduling capability, its core is made of two kinds of basic schedules:  decay schedules  and  cyclic schedules .  Each kind of schedule conforms to a formula which is relevant for understanding the schedules behavior .  Still, both types of schedules can be called and iterated like we saw in the  getting started  tutorial .","id":"docs/tutorials/basic-schedules.html#basic-schedules"},{"body":"public   Step   —   parametric type A step schedule decays exponentially by  γ  every step in  step_sizes . The output conforms to where  sum(step_sizes[1:(i - 1)]) < t <= sum(step_sizes[1:i])","id":"docstrings/ParameterSchedulers.Step.html"},{"body":"Interpolating schedules Sometimes, we want to specify a schedule in different units than our iteration state .  Below, we ’ ll see two common examples where this might be the case, and how  Interpolator  can make our lives a bit easier . In our first example, we ’ ll consider a situation where our iteration state is continuous .  This is typical in differential equation solvers where we iterate over time (i . e .  over  dt, 2dt, 3dt, ...  where  dt  is the solver time step) .  Conceptually, each step over time should move our schedule forward  “ by one ”  (i . e .  over iteration states  1, 2, 3, ... ) .  To move from one iteration scheme to the other, we want to  interpolate  our time range at a rate of  dt . Notice that our schedule changes around 1 second (half way through the simulation) . For the second example, we ’ ll look at a machine learning use - case .  We want to write our schedule in terms of epochs, but our training loop iterates the scheduler every mini - batch .","id":"docs/tutorials/complex-schedules.html#interpolating-schedules"},{"body":"private   next!   —   function Advance  iter  by one iteration (if  iter.advance(state) == true ) and return the next value . See also  ParameterSchedulers.Stateful .","id":"docstrings/ParameterSchedulers.next!.html"},{"body":"private   reverse   —   function Return a reverse function such that  reverse(f, period)(t) == f(period - t) .","id":"docstrings/ParameterSchedulers.reverse.html"},{"body":"public   CosAnneal   —   parametric type A cosine annealing schedule (see  “ SGDR: Stochastic Gradient Descent with Warm Restarts ” ) The output conforms to This schedule is also referred to as  “ cosine annealing (with warm restarts) ” in machine learning literature .","id":"docstrings/ParameterSchedulers.CosAnneal.html"},{"body":"public   Sequence   —   parametric type A sequence of schedules . The output of this schedule is the concatenation of  schedules  where each schedule is evaluated for each step size in  step_sizes . Note that  schedules  can also be a vector of numbers (not just schedules) .","id":"docstrings/ParameterSchedulers.Sequence.html"},{"body":"Schedule cheatsheet for other frameworks If you are coming from PyTorch or Tensorflow, the following table should help you find the corresponding schedule policy in ParameterSchedulers . jl . PyTorch typically wraps an optimizer as the first argument, but we ignore that functionality in the table .  To wrap a Flux . jl optimizer with a schedule from the rightmost column, use  ParameterSchedules.Scheduler . The variable  lr  in the middle/rightmost column refers to the initial learning rate of the optimizer . PyTorch Tensorflow ParameterSchedulers . jl  LambdaLR(_, lr_lambda)  N/A  lr_lambda   MultiplicativeLR(_, lr_lambda)  N/A N/A  StepLR(_, step_size, gamma)   ExponentialDecay(lr, step_size, gamma, True)   Step(lr, gamma, step_size)   MultiStepLR(_, milestones, gamma)  N/A  Step(lr, gamma, milestones)   ConstantLR(_, factor, total_iters)  N/A  Sequence(lr * factor => total_iters, lr => nepochs)   LinearLR(_, start_factor, end_factor, total_iters)  N/A  Sequence(Triangle(lr * start_factor, lr * end_factor, 2 * total_iters) => total_iters, lr => nepochs)   ExponentialLR(_, gamma)   ExponentialDecay(lr, 1, gamma, False)   Exp(lr, gamma)  N/A  ExponentialDecay(lr, steps, gamma, False)   Interpolator(Exp(lr, gamma), steps)   CosineAnnealingLR(_, T_max, eta_min)   CosineDecay(lr, T_max, eta_min)   CosAnneal(lr, eta_min, T_0, false)   CosineAnnealingRestarts(_, T_0, 1, eta_min)   CosineDecayRestarts(lr, T_0, 1, 1, eta_min)   CosAnneal(lr, eta_min, T_0)   CosineAnnealingRestarts(_, T_0, T_mult, eta_min)   CosineDecayRestarts(lr, T_0, T_mult, 1, alpha)  See  below  N/A  CosineDecayRestarts(lr, T_0, T_mult, m_mul, alpha)  See  below   SequentialLR(_, schedulers, milestones)  N/A  Sequence(schedulers, milestones)   ReduceLROnPlateau(_, mode, factor, patience, threshold, 'abs', 0)  N/A See  below   CyclicLR(_, base_lr, max_lr, step_size, step_size, 'triangular', _, None)  N/A  Triangle(base_lr, max_lr, step_size)   CyclicLR(_, base_lr, max_lr, step_size, step_size, 'triangular2', _, None)  N/A  TriangleDecay2(base_lr, max_lr, step_size)   CyclicLR(_, base_lr, max_lr, step_size, step_size, 'exp_range', gamma, None)  N/A  TriangleExp(base_lr, max_lr, step_size, gamma)   CyclicLR(_, base_lr, max_lr, step_size, step_size, _, _, scale_fn)  N/A See  Arbitrary looping schedules  N/A  InverseTimeDecay(lr, 1, decay_rate, False)   Inv(lr, decay_rate, 1)  N/A  InverseTimeDecay(lr, decay_step, decay_rate, False)   Interpolator(Inv(lr, decay_rate, 1), decay_step)  N/A  PolynomialDecay(lr, decay_steps, 0, power, False)   Poly(lr, power, decay_steps) ","id":"docs/cheatsheet.html#schedule-cheatsheet-for-other-frameworks"},{"body":"Scheduling optimizers A schedule by itself is not helpful; we need to use the schedules to adjust parameters .  In this tutorial, we will examine three ways to do just that  —  iterating the schedule, using a stateful iterator, and using an scheduled optimizer .","id":"docs/tutorials/optimizers.html#scheduling-optimizers"},{"body":"Generic interface All schedules must implement the interface  (s::MySchedule)(t)  which returns the schedule value at iteration  t .  Additionally, a schedule must implement  Base.iterate  from the  iteration interface  and  Base.eltype  when possible .  This is the minimal interface required to work with the rest of ParameterSchedulers . jl . It is  strongly  recommended that your schedule subtypes  ParameterSchedulers.AbstractSchedule .  This will define  Base.iterate  and several other pieces of the iteration interface for you . AbstractSchedule  takes a single type parameter,  IsFinite .  Below are the possible values . AbstractSchedule{true} : use for finite schedules Base.IteratorSize  is auto - implemented as  Base.HasLength() Base.axes(s)  is auto - implemented as  1:length(s) Requires  Base.length  to be implemented by you AbstractSchedule{false} : use for infinite schedules Base.IteratorSize  is auto - implemented as  Base.IsInfinite() Base.axes  is auto - implemented as  OneToInf() AbstractSchedule{missing} : use for schedules where infinite/finite is unknown Base.IteratorSize  is auto - implemented as  Base.SizeUnknown() Base.axes  is auto - implemented as  OneToInf() AbstractSchedule{T} : use for schedules where the length depends on  T Base.IteratorSize  is auto - implemented as  Base.IteratorSize(T)","id":"docs/interfaces/generic.html#generic-interface"},{"body":"Arguments schedules : a vector of schedules or numbers step_sizes : a vector of iteration lengths for each schedule","id":"docstrings/ParameterSchedulers.Sequence.html#arguments"},{"body":"Composing schedules While the functionality above is already quite powerful, we are still limited to constant values for our schedule ’ s fields .  Just like we use schedules to adjust our model ’ s hyper - parameters, we might want to use schedules to adjust our schedule ’ s fields !  You can do this with  ComposedSchedule . In fact, many of the cyclic schedules are built on top of this feature .  As an exercise, we will build  SinDecay10  which behaves similar to  SinDecay2  but dropping the peak amplitude by a factor of 10 each time . We passed  ComposedSchedule  two arguments: a schedule whose fields we want to compose a tuple that dictates how each field changes The  parameters  matches the arguments to the  Sin  positional constructor:  (range, offset, period) .  We specified that the range should decay exponentially by a factor of 10 every  period  steps . By default,  ComposedSchedule  will use the default constructor to create a new instance of the composed schedule .  In our example, this corresponds to something like If this is not going to work for your schedule, then you can use the three argument form:  ComposedSchedule(compose_fn, schedule, parameters) .   schedule  and  parameters  are the same arguments as before .   compose_fn  is the new argument that is a function of the form  (schedule, parameter_values) -> new_schedule .  Here is an dummy example that works the same as before but illustrates how to use  compose_fn .","id":"docs/tutorials/complex-schedules.html#composing-schedules"},{"body":"Cosine annealing variants In addition to the plain cosine annealing w/ warm restarts schedule, we may want to decay the peak learning rate or increase the period .  Both can be done using  ComposedSchedule  or  Sequence . Let ’ s start with the simpler task: decaying the learning rate . To increase the period by a fixed multiple, we should think of each period of the schedule as an individual schedule concatenated together .  This is exactly what  Sequence  is except that there is no limit to the number of periods that we concatenate together .  Fortunately,  Sequence  accepts  Base.Generators .  When combined with  InfiniteArrays . jl , we can create an infinite sequence of individual schedules .","id":"docs/cheatsheet.html#cosine-annealing-variants"},{"body":"Available Schedules This is a table of the common schedules implemented, but ParameterSchedulers provides utilities for creating more exotic schedules as well .  The  higher order schedules  should make it so that you will rarely need to write a schedule from scratch . You can read  this paper  for more information on the schedules below . Step(;λ, γ, step_sizes) Exponential decay by  γ  every step in  step_sizes Exp(;λ, γ) Exponential decay by  γ  every iteration CosAnneal(;λ0, λ1, period) Cosine annealing Triangle(;λ0, λ1, period) Triangle wave  function TriangleDecay2(;λ0, λ1, period) Triangle wave  function with half the amplitude every  period TriangleExp(;λ0, λ1, period, γ) Triangle wave  function with exponential amplitude decay at rate  γ Poly(;λ, p, max_iter) Polynomial decay at degree  p Inv(;λ, γ, p) Inverse decay at rate  (1 + tγ)^p Sin(;λ0, λ1, period) Sine function SinDecay2(;λ0, λ1, period) Sine function with half the amplitude every  period SinExp(;λ0, λ1, period) Sine function with exponential amplitude decay at rate  γ","id":"README.html#available-schedules"},{"body":"Sine ramp Another common ramp function is a half period of a sine wave .  We can use  Sin  and the same technique as the previous section .","id":"docs/tutorials/warmup-schedules.html#sine-ramp"},{"body":"ReduceLROnPlateau  style schedules Unlike PyTorch, ParameterSchedulers . jl doesn ’ t create a monolithic schedule to control dynamic schedules .  Instead,  ParameterSchedulers.Stateful  has an  advance  keyword argument that can allow for arbitrary advancement of schedules based on a predicate function .  When combined with  Flux.plateau  as the predicate, we get  ReduceLROnPlateau . Using this approach, we can be more flexible than PyTorch .  You can use any schedule (not just exponential decay) and arbitrary predicates .  Make sure to check out the  Flux docmentation on  “ patience helpers ”  for more ways to customize the predicate (e . g .  the  'min'  mode for  ReduceLROnPlateau ) .","id":"docs/cheatsheet.html#reducelronplateau-style-schedules"},{"body":"private   symmetric   —   function Return a symmetric function such that for  t ∈ [1, period / 2) , the symmetric function evaluates to  f(t) , and when  t ∈ [period / 2, period) , the symmetric functions evaluates to  f(period - t) .","id":"docstrings/ParameterSchedulers.symmetric.html"},{"body":"Arguments range == abs(λ0 - λ1) : the dynamic range (given by the endpoints) offset == min(λ0, λ1) : the offset / minimum value period::Integer : the period","id":"docstrings/ParameterSchedulers.SinDecay2.html#arguments"},{"body":"Arguments range == abs(λ0 - λ1) : the dynamic range (given by the endpoints) offset == min(λ0, λ1) : the offset / minimum value period::Integer : the period γ : the decay rate","id":"docstrings/ParameterSchedulers.SinExp.html#arguments"},{"body":"Arguments range == abs(λ0 - λ1) : the dynamic range (given by the endpoints) offset == min(λ0, λ1) : the offset / minimum value period::Integer : the period","id":"docstrings/ParameterSchedulers.Sin.html#arguments"},{"body":"public   Exp   —   parametric type A exponential decay schedule at rate  γ . The output conforms to","id":"docstrings/ParameterSchedulers.Exp.html"},{"body":"private   Stateful   —   parametric type Create a stateful iterator around  schedule . Pass in a predicate,  advance(state) , to conditionally control iteration . See also  ParameterSchedulers.next!  and  ParameterSchedulers.reset! .","id":"docstrings/ParameterSchedulers.Stateful.html"},{"body":"Sequences of schedules Finally, we might concatenate sequences of schedules, applying each one for a given length, then switch to the next schedule in the order .  A  Sequence  schedule lets us do this .  For example, we can start with a triangular schedule, then switch to a more conservative exponential schedule half way through training . Alternatively, we might simply wish to manually set the parameter every interval .   Sequence  also accepts a vector of numbers . Sequence  also accepts  Base.Generators . We can also pass a separate generator for  schedules  and  step_sizes .  When only a single generator is passed,  step_sizes  is the iterator that the generator is based on . Lastly, the schedules in a  Sequence  can use  Shifted  to start at an iteration other than  t = 1 .","id":"docs/tutorials/complex-schedules.html#sequences-of-schedules"},{"body":"Using  Shifted  to start the  “ real ”  schedule Sometimes, the  “ real ”  schedule doesn ’ t start at the  initial_lr  like  Exp .  Suppose we want a sine warmup followed by a  Triangle  schedule .   Triangle  starts at  min(λ0, λ1) , so to get this correct, we want to start the  Triangle  half - way through its first period .  We can use  Shifted  to do this .","id":"docs/tutorials/warmup-schedules.html#using-shifted-to-start-the-real-schedule"},{"body":"Lambda schedule Below we implement  Lambda  to illustrate what is required for a custom schedule .   Lambda  simply wraps a function,  f , and the schedule value at iteration  t  is  f(t) . Next we implement the necessary interfaces .  The easiest way to define  (s::Lambda)(t) , then rely on that to define the iteration behavior . Sometimes, it might be more efficient to define  Base.iterate  separately from  s(t) .  See  Step  for an example what this might look like . You can also define optional parts of the iteration interface if you choose .  They are not required for ParameterSchedulers . jl . Once you are done defining the above interfaces, you can start using  Lambda  like any other schedule .  For example, below we create a  Loop  where the interval is defined as a  Lambda","id":"docs/interfaces/generic.html#lambda-schedule"},{"body":"Examples","id":"docstrings/ParameterSchedulers.Scheduler.html#examples"},{"body":"Arguments range == abs(λ0 - λ1) : the dynamic range (given by the endpoints) offset == min(λ0, λ1) : the offset / minimum value period::Integer : the period","id":"docstrings/ParameterSchedulers.Triangle.html#arguments"},{"body":"Arbitrary looping schedules Let ’ s take the notion of arbitrary schedules one step further, and instead define how a schedule behaves over a given interval or period .  Then, we would like to loop that interval over and over .  This is precisely what  Loop  achieves .  For example, we may want to apply an  Exp  schedule for 10 iterations, then repeat from the beginning, and so forth . Or we can just an arbitrary function to loop (e . g .   log ) .","id":"docs/tutorials/complex-schedules.html#arbitrary-looping-schedules"},{"body":"Getting started All schedules types in ParameterSchedulers . jl behave as callable iterators .  For example, we can call the simple exponential decay schedule ( Exp ) below at a specific iteration: The iterations are unitless .  So, if you index a schedule every epoch, then the  s(i)  is parameter value at epoch  i . We can also use the schedule in an iterable context like a  for - loop: Many schedules such as  Exp  are infinite iterators, so iterating over them will result in an infinite loop .  You can use  Base.IteratorSize  to check if a schedule has infinite length . Notice that the value of  s(1)  and  s(5)  is unchanged even though we accessed the schedule once by calling them and again in the  for - loop .  This is because all schedules in ParameterSchedulers . jl are  immutable .  If you want a stateful (mutable) schedule, then you can use  ParameterSchedulers.Stateful : We used  ParameterSchedulers.next!  to advance the stateful iterator .  Notice that  stateful_s  stores a reference to  s  and the current iteration state (which is  3  since we advanced the iterator twice) .  We can reset the mutable iteration state too: Also note that  Stateful  cannot be called (or iterated with  Base.iterate ):","id":"docs/tutorials/getting-started.html#getting-started"},{"body":"public   ComposedSchedule   —   parametric type A  schedule  whose fields are given by  parameters.(t)  at iteration  t . At each step  t , this gets a new set of parameters with  parameters.(t) , then creates a new  schedule  given the first (optional) argument . The new  schedule(t)  is the returned value .","id":"docstrings/ParameterSchedulers.ComposedSchedule.html"},{"body":"Arguments start / λ : the base value decay / γ : the decay rate degree / p::Integer : the degree of decay","id":"docstrings/ParameterSchedulers.Inv.html#arguments"},{"body":"Working with Flux optimizers Currently, we are porting  Scheduler  to Flux . jl . It may be renamed once it is ported out of this package . The API will also undergo minor changes . While the approaches above can be helpful when dealing with fine - grained training loops, it is usually simpler to just use a  ParameterSchedulers.Scheduler . The scheduler,  opt , can be used anywhere a Flux optimizer can .  For example, it can be passed to  Flux.train! : Finally, you might be interested in reading  Interpolating schedules  to see how to specify a schedule in terms of epochs but iterate it at the granularity of batches .","id":"docs/tutorials/optimizers.html#working-with-flux-optimizers"},{"body":"Decay schedules A decay schedule is defined by the following formula: where   is the schedule output,   is the base (initial) value, and   is the decay function .  Typically, the decay function is expected to be bounded between  , but this requirement is only suggested and not enforced . For example, here is an exponential decay schedule: As you can see above,  Exp  is a type of decay schedule .  Below is a list of all the decay schedules implemented, and the parameters and decay functions for each one . Schedule Parameters Decay Function  Step   λ ,  γ ,  step_sizes    where    Exp   λ ,  γ     Poly   λ ,  p ,  max_iter     Inv   λ ,  γ ,  p   ","id":"docs/tutorials/basic-schedules.html#decay-schedules"},{"body":"private   AbstractSchedule   —   parametric type Inherit from this type to create a custom schedule . Type parameter  IsFinite  can take three values: true : for finite schedules false : for infinite schedules missing : for higher - order schedules where the length is unknown (similar to  Base.SizeUnknown() ) T : a type  T  that indicates all iterator interface functions should forward to this type Read the  generic interface  docs section for more .","id":"docstrings/ParameterSchedulers.AbstractSchedule.html"},{"body":"Arguments f : the schedule to loop period::Integer : how often to loop","id":"docstrings/ParameterSchedulers.Loop.html#arguments"},{"body":"public   SinDecay2   —   function A sine wave schedule with  period  and half the amplitude each cycle . The output conforms to where  Sin(t)  is  abs(sin(π * (t - 1) / period))  (see  Sin ) .","id":"docstrings/ParameterSchedulers.SinDecay2.html"},{"body":"Arguments range0 / λ0 : the first range endpoint range1 / λ1 : the second range endpoint period::Integer : the period","id":"docstrings/ParameterSchedulers.TriangleDecay2.html#arguments"}]