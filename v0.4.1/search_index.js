var documenterSearchIndex = {"docs":
[{"location":"api/general/#General-API-reference","page":"General API reference","title":"General API reference","text":"","category":"section"},{"location":"api/general/#Scheduler-API-reference","page":"General API reference","title":"Scheduler API reference","text":"","category":"section"},{"location":"api/general/","page":"General API reference","title":"General API reference","text":"ParameterSchedulers.Scheduler","category":"page"},{"location":"api/general/#ParameterSchedulers.Scheduler","page":"General API reference","title":"ParameterSchedulers.Scheduler","text":"Scheduler{T, F} <: Optimiser.AbstractRule\nScheduler(constructor, schedules::AbstractSchedule...)\nScheduler(constructor; field_a = schedule_a, field_b = schedule_b, ...)\n\nWrap one or more schedules and optimizer together with a Scheduler. On each call to Optimisers.apply!, the schedules are iterated and constructor is used to invoke an optimization rule with updated parameters. The Scheduler can be used anywhere an Optimisers.jl optimizer is used.\n\nIf passed a single schedule and optimizer rule, the scheduler updates the learning, opt.eta. To adjust multiple hyperparameters, pass in multiple schedules as arguments or keywords. These will be iterated in order and passed onto to constructor (i.e. constructor should accept the appropriate number of arguments/keywords).\n\nArguments\n\nconstructor: a constructor that creates an optimization rule given some   parameters (e.g. Optimisers.AdamW; note the lack of ())\nschedules: the list of optimization rule hyperparameters to schedule as   multiple (named) arguments\n\nExamples\n\n# cosine annealing schedule for Descent\njulia> opt = Scheduler(Descent, CosAnneal(l0 = 0.1, l1 = 0.8, period = 10));\n\n# schedule learning rate and momentum of Momentum\njulia> opt = Scheduler(Momentum, CosAnneal(l0 = 0.1, l1 = 0.8, period = 10), Exp(0.999, 0.8));\n\n# schedule the weight decay term of AdamW with a custom fixed learning rate\njulia> opt = Scheduler(AdamW, eta = 1e-4, decay = Exp(1e-3, 0.7));\n\n\n\n\n\n","category":"type"},{"location":"api/general/#State-schedule-API-reference","page":"General API reference","title":"State schedule API reference","text":"","category":"section"},{"location":"api/general/","page":"General API reference","title":"General API reference","text":"ParameterSchedulers.Stateful\nParameterSchedulers.next!\nParameterSchedulers.reset!","category":"page"},{"location":"api/general/#ParameterSchedulers.Stateful","page":"General API reference","title":"ParameterSchedulers.Stateful","text":"Stateful{T, S}\nStateful(schedule::T; advance = state -> true)\n\nCreate a stateful iterator around schedule. Pass in a predicate, advance(state), to conditionally control iteration. See also ParameterSchedulers.next! and ParameterSchedulers.reset!.\n\n\n\n\n\n","category":"type"},{"location":"api/general/#ParameterSchedulers.next!","page":"General API reference","title":"ParameterSchedulers.next!","text":"next!(iter::Stateful)\n\nAdvance iter by one iteration (if iter.advance(state) == true) and return the next value. See also ParameterSchedulers.Stateful.\n\n\n\n\n\n","category":"function"},{"location":"api/general/#ParameterSchedulers.reset!","page":"General API reference","title":"ParameterSchedulers.reset!","text":"reset!(iter::Stateful)\n\nReset iter to its initial state. See also ParameterSchedulers.Stateful.\n\n\n\n\n\n","category":"function"},{"location":"api/general/#Utility-functions-API-reference","page":"General API reference","title":"Utility functions API reference","text":"","category":"section"},{"location":"api/general/","page":"General API reference","title":"General API reference","text":"Modules = [ParameterSchedulers]\nPages = [\"utils.jl\"]","category":"page"},{"location":"api/general/#ParameterSchedulers.depkwargs-Tuple{Symbol, Any, Vararg{Pair}}","page":"General API reference","title":"ParameterSchedulers.depkwargs","text":"depkwargs(fn::Symbol, kwargs, remaps::Pair...)\n\nRemap depracated kwargs when calling fn according to each pair in remaps. Such remaps parameter provides the mapping between old_param_name => new_param_name.\n\n\n\n\n\n","category":"method"},{"location":"api/general/#ParameterSchedulers.reverse-Tuple{Any, Any}","page":"General API reference","title":"ParameterSchedulers.reverse","text":"reverse(f, period)\n\nReturn a reverse function such that reverse(f, period)(t) == f(period - t).\n\n\n\n\n\n","category":"method"},{"location":"api/general/#ParameterSchedulers.symmetric-Tuple{Any, Any}","page":"General API reference","title":"ParameterSchedulers.symmetric","text":"symmetric(f, period)\n\nReturn a symmetric function such that for t ∈ [1, period / 2), the symmetric function evaluates to f(t), and when t ∈ [period / 2, period), the symmetric functions evaluates to f(period - t).\n\n\n\n\n\n","category":"method"},{"location":"tutorials/complex-schedules/#Complex-schedules","page":"Complex schedules","title":"Complex schedules","text":"","category":"section"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"using ParameterSchedulers # hide","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"While the basic schedules tutorial covered the simple decay and cyclic schedules available in ParameterSchedulers.jl, it is possible to more complex schedules for added flexibility.","category":"page"},{"location":"tutorials/complex-schedules/#Arbitrary-functions","page":"Complex schedules","title":"Arbitrary functions","text":"","category":"section"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Sometimes, a simple function is the easiest way to specify a schedule. Unlike PyTorch's LambdaLR, ParameterSchedulers.jl allows you to use the function directly. The schedule output is f(t). While you can use f directly to build up complex schedules (as we'll see in the next section), it lacks functionality like Base.iterate. If you want f to behave more formally like a schedule, implement the generic interface for schedules.","category":"page"},{"location":"tutorials/complex-schedules/#Arbitrary-looping-schedules","page":"Complex schedules","title":"Arbitrary looping schedules","text":"","category":"section"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Let's take the notion of arbitrary schedules one step further, and instead define how a schedule behaves over a given interval or period. Then, we would like to loop that interval over and over. This is precisely what Loop achieves. For example, we may want to apply an Exp schedule for 10 iterations, then repeat from the beginning, and so forth.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"using UnicodePlots\n\ns = Loop(Exp(start = 0.1, decay = 0.4), 10)\nt = 1:25 |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Or we can just an arbitrary function to loop (e.g. log).","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"s = Loop(log, 10)\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"tutorials/complex-schedules/#Sequences-of-schedules","page":"Complex schedules","title":"Sequences of schedules","text":"","category":"section"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Finally, we might concatenate sequences of schedules, applying each one for a given length, then switch to the next schedule in the order. A Sequence schedule lets us do this. For example, we can start with a triangular schedule, then switch to a more conservative exponential schedule half way through training.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"nepochs = 50\ns = Sequence([Triangle(l0 = 0.0, l1 = 0.5, period = 5), Exp(start = 0.5, decay = 0.5)],\n             [nepochs ÷ 2, nepochs ÷ 2])\n\nt = 1:nepochs |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Alternatively, we might simply wish to manually set the parameter every interval. Sequence also accepts a vector of numbers.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"s = Sequence(1e-1 => 5, 5e-2 => 4, 3.4e-3 => 10)\nt = 1:20 |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Sequence also accepts Base.Generators.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"s = Sequence(2 / t for t in 1:10)\nt = 1:50 |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"We can also pass a separate generator for schedules and step_sizes. When only a single generator is passed, step_sizes is the iterator that the generator is based on.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Lastly, the schedules in a Sequence can use Shifted to start at an iteration other than t = 1.","category":"page"},{"location":"tutorials/complex-schedules/#Interpolating-schedules","page":"Complex schedules","title":"Interpolating schedules","text":"","category":"section"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Sometimes, we want to specify a schedule in different units than our iteration state. Below, we'll see two common examples where this might be the case, and how Interpolator can make our lives a bit easier.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"In our first example, we'll consider a situation where our iteration state is continuous. This is typical in differential equation solvers where we iterate over time (i.e. over dt, 2dt, 3dt, ... where dt is the solver time step). Conceptually, each step over time should move our schedule forward \"by one\" (i.e. over iteration states 1, 2, 3, ...). To move from one iteration scheme to the other, we want to interpolate our time range at a rate of dt.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"dt = 1e-3 # simulation time step in seconds\nT = 2 # simulate 2 seconds\n# our parameter is 1e-2 for the first half of the simulation\n# then it drops to 1e-3 for the second half of the simulation\n# we interpolate at a rate of dt\ns = Interpolator(Sequence(1e-2 => cld(T, dt) / 2, 1e-3 => cld(T, dt) / 2), dt)\n\n# the time range of the simulation in seconds\ntrange = dt:dt:T |> collect\nlineplot(trange, s.(trange); border = :none)","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"Notice that our schedule changes around 1 second (half way through the simulation).","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"For the second example, we'll look at a machine learning use-case. We want to write our schedule in terms of epochs, but our training loop iterates the scheduler every mini-batch.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"using Flux\nusing Optimisers\nusing ParameterSchedulers: Scheduler\n\nnepochs = 3\ndata = [(Flux.rand32(4, 10), rand([-1, 1], 1, 10)) for _ in 1:3]\nm = Chain(Dense(4, 4, tanh), Dense(4, 1, tanh))\ns = Interpolator(Sequence(1f-2 => 1, Exp(1f-2, 2f0) => 2), length(data))\nopt = Scheduler(Optimisers.Descent, s)\nopt_st = Flux.setup(opt, m)\nfor epoch in 1:nepochs\n    for (i, (x, y)) in enumerate(data)\n        global opt_st, m\n        step = opt_st.layers[1].weight.state.t\n        println(\"epoch: $epoch, batch: $i, sched step = $step\")\n        g = Flux.gradient(m -> Flux.mse(m(x), y), m)[1]\n        opt_st, m = Flux.update!(opt_st, m, g)\n    end\nend","category":"page"},{"location":"tutorials/complex-schedules/#Composing-schedules","page":"Complex schedules","title":"Composing schedules","text":"","category":"section"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"While the functionality above is already quite powerful, we are still limited to constant values for our schedule's fields. Just like we use schedules to adjust our model's hyper-parameters, we might want to use schedules to adjust our schedule's fields! You can do this with ComposedSchedule.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"In fact, many of the cyclic schedules are built on top of this feature. As an exercise, we will build SinDecay10 which behaves similar to SinDecay2 but dropping the peak amplitude by a factor of 10 each time.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"function SinDecay10(range, offset, period)\n    parameters = (Step(range, 0.1, period), offset, period)\n    ComposedSchedule(Sin(range, offset, period), parameters)\nend\n\nSinDecay10(0.5, 0.1, 5)","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"We passed ComposedSchedule two arguments:","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"a schedule whose fields we want to compose\na tuple that dictates how each field changes","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"The parameters matches the arguments to the Sin positional constructor: (range, offset, period). We specified that the range should decay exponentially by a factor of 10 every period steps.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"By default, ComposedSchedule will use the default constructor to create a new instance of the composed schedule. In our example, this corresponds to something like","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"ps = map(p -> p(t), composed.parameters)\ns = typeof(composed.schedule)(ps...)","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"If this is not going to work for your schedule, then you can use the three argument form: ComposedSchedule(compose_fn, schedule, parameters). schedule and parameters are the same arguments as before. compose_fn is the new argument that is a function of the form (schedule, parameter_values) -> new_schedule. Here is an dummy example that works the same as before but illustrates how to use compose_fn.","category":"page"},{"location":"tutorials/complex-schedules/","page":"Complex schedules","title":"Complex schedules","text":"function SinDecay10(range, offset, period)\n    parameters = (Step(range, 0.1, period), offset, period)\n    ComposedSchedule(Sin(range, offset, period), parameters) do schedule, parameter_values\n        @show schedule\n        @show parameter_values\n        Sin(parameter_values...)\n    end\nend","category":"page"},{"location":"api/complex/#Complex-schedule-API-reference","page":"Complex schedule API reference","title":"Complex schedule API reference","text":"","category":"section"},{"location":"api/complex/","page":"Complex schedule API reference","title":"Complex schedule API reference","text":"Modules = [ParameterSchedulers]\nPages = [\"complex.jl\"]\nFilter = f -> !(f === ParameterSchedulers.Stateful) &&\n              !(f === ParameterSchedulers.next!) &&\n              !(f === ParameterSchedulers.reset!)","category":"page"},{"location":"api/complex/#ParameterSchedulers.ComposedSchedule","page":"Complex schedule API reference","title":"ParameterSchedulers.ComposedSchedule","text":"ComposedSchedule([(s, ps) -> T(ps...),] schedule::T, parameters)\n\nA schedule whose fields are given by parameters.(t) at iteration t.\n\nAt each step t, this gets a new set of parameters with parameters.(t), then creates a new schedule given the first (optional) argument. The new schedule(t) is the returned value.\n\n\n\n\n\n","category":"type"},{"location":"api/complex/#ParameterSchedulers.Constant","page":"Complex schedule API reference","title":"ParameterSchedulers.Constant","text":"Constant{T}\nConstant(value)\n\nA constant schedule that is always value.\n\n\n\n\n\n","category":"type"},{"location":"api/complex/#ParameterSchedulers.Interpolator","page":"Complex schedule API reference","title":"ParameterSchedulers.Interpolator","text":"Interpolator{T, S, F}\nInterpolator(schedule, rate, ceil_fn = x -> ceil(Int, x))\n\nA schedule whose output is schedule(t / rate) (i.e. it interpolates schedule(t)).\n\nThis can be useful when your code iterates over real numbers at a fixed rate (e.g. in a fixed time step differential solver), but you want to use a schedule that iterates discretely over integers.\n\nIt could also be used to specify schedule in units of epochs, while iterating it in units of mini-batches.\n\nSpecify ceil_fn to apply a ceiling (or flooring) function to t / rate.\n\n\n\n\n\n","category":"type"},{"location":"api/complex/#ParameterSchedulers.Loop","page":"Complex schedule API reference","title":"ParameterSchedulers.Loop","text":"Loop{T, S<:Integer}\nLoop(f, period)\n\nCreate a schedule that loops f every period iterations. f must be callabe (a function or schedule).\n\nArguments\n\nf: the schedule to loop\nperiod::Integer: how often to loop\n\n\n\n\n\n","category":"type"},{"location":"api/complex/#ParameterSchedulers.Sequence","page":"Complex schedule API reference","title":"ParameterSchedulers.Sequence","text":"Sequence{T, S}\nSequence(schedules, step_sizes)\nSequence(schedule1 => step1, schedule2 => step2, ...)\n\nA sequence of schedules. The output of this schedule is the concatenation of schedules where each schedule is evaluated for each step size in step_sizes.\n\nNote that schedules can also be a vector of numbers (not just schedules).\n\nArguments\n\nschedules: a vector of schedules or numbers\nstep_sizes: a vector of iteration lengths for each schedule\n\n\n\n\n\n","category":"type"},{"location":"api/complex/#ParameterSchedulers.Shifted","page":"Complex schedule API reference","title":"ParameterSchedulers.Shifted","text":"Shifted(schedule, offset)\n\nA schedule who's starting iteration is shifted to offset. (i.e. calling an Shifted with t = 1 is equivalent to calling schedule with t = offset)\n\n\n\n\n\n","category":"type"},{"location":"api/complex/#ParameterSchedulers.Shortened","page":"Complex schedule API reference","title":"ParameterSchedulers.Shortened","text":"Shortened{T}\nShortened(schedule, nsteps)\n\nA schedule that mimics schedule but throws a BoundsError if accessed beyond nsteps.\n\n\n\n\n\n","category":"type"},{"location":"api/complex/#ParameterSchedulers.OneCycle-Tuple{Any, Any}","page":"Complex schedule API reference","title":"ParameterSchedulers.OneCycle","text":"OneCycle(nsteps, maxval;\n         startval = maxval / 25,\n         endval = maxval / 1f5,\n         percent_start = 0.25)\n\nCreates a one-cycle cosine schedule over nsteps steps warming up from startval up to maxval for ceil(percent_start * nsteps), then back to endval (see Super-Convergence: Very Fast Training of Neural Networks Using Large Learning Rates).\n\n\n\n\n\n","category":"method"},{"location":"tutorials/warmup-schedules/#Warm-up-Schedules","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"","category":"section"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"A popular technique for scheduling learning rates is \"warming-up\" the optimizer by ramping the learning rate up from near zero to the \"true\" initial learning rate, then starting the \"real\" schedule. This is easily implementable with ParameterSchedulers.jl using Sequence.","category":"page"},{"location":"tutorials/warmup-schedules/#One-cycle-cosine-schedule","page":"Warm-up Schedules","title":"One cycle cosine schedule","text":"","category":"section"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"A one-cycle cosine schedule is the most popular warm-up schedule. It ramps up once and ramps down once using a cosine waveform. Since this schedule is so common, we provide a convenience constructor in ParameterSchedulers.jl, OneCycle.","category":"page"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"using ParameterSchedulers\nusing UnicodePlots\n\nnsteps = 10\nmaxval = 1f-1\nonecycle = OneCycle(10, 1f-1; percent_start = 0.4)\n\nt = 1:nsteps |> collect\nlineplot(t, onecycle.(t); border = :none)","category":"page"},{"location":"tutorials/warmup-schedules/#Linear-ramp","page":"Warm-up Schedules","title":"Linear ramp","text":"","category":"section"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"Suppose we want to increase our learning rate using a linear ramp function. We can achieve this by running a Triangle schedule for a half-period.","category":"page"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"using ParameterSchedulers\nusing UnicodePlots\n\nmin_lr = 1e-6 # don't actually start with lr = 0\ninitial_lr = 1e-2\nwarmup = 20 # warmup for 20 epochs\n\nramp = Triangle(l0 = min_lr, l1 = initial_lr, period = 2 * warmup)\n\nt = 1:warmup |> collect\nlineplot(t, ramp.(t); border = :none)","category":"page"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"Of course, if we run the Triangle for more than warmup iterations, it will be periodic. So, we want to make sure to start our \"real\" schedule immediately after half a period.","category":"page"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"total_iters = 100\n\n# let's wrap it all up in a convenience constructor\nWarmupLinear(startlr, initlr, warmup, total_iters, schedule) =\n    Sequence(Triangle(l0 = startlr, l1 = initlr, period = 2 * warmup) => warmup,\n             schedule => total_iters)\n\ns = WarmupLinear(min_lr, initial_lr, warmup, total_iters, Exp(initial_lr, 0.8))\nt = 1:total_iters |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"tutorials/warmup-schedules/#Sine-ramp","page":"Warm-up Schedules","title":"Sine ramp","text":"","category":"section"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"Another common ramp function is a half period of a sine wave. We can use Sin and the same technique as the previous section.","category":"page"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"WarmupSin(startlr, initlr, warmup, total_iters, schedule) =\n    Sequence(Sin(l0 = startlr, l1 = initlr, period = 2 * warmup) => warmup,\n             schedule => total_iters)\n\ns = WarmupSin(min_lr, initial_lr, warmup, total_iters, Exp(initial_lr, 0.8))\nt = 1:total_iters |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"tutorials/warmup-schedules/#Using-Shifted-to-start-the-\"real\"-schedule","page":"Warm-up Schedules","title":"Using Shifted to start the \"real\" schedule","text":"","category":"section"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"Sometimes, the \"real\" schedule doesn't start at the initial_lr like Exp. Suppose we want a sine warmup followed by a Triangle schedule. Triangle starts at min(λ0, λ1), so to get this correct, we want to start the Triangle half-way through its first period. We can use Shifted to do this.","category":"page"},{"location":"tutorials/warmup-schedules/","page":"Warm-up Schedules","title":"Warm-up Schedules","text":"# shift the Triangle by half a period + 1 to start at the peak\ntri = Shifted(Triangle(l0 = min_lr, l1 = initial_lr, period = 10), 6)\ns = WarmupSin(min_lr, initial_lr, warmup, total_iters, tri)\nt = 1:50 |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"interface/#Generic-interface","page":"Schedule interface","title":"Generic interface","text":"","category":"section"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"All schedules must implement the interface (s::MySchedule)(t) which returns the schedule value at iteration t. Additionally, a schedule must implement Base.iterate from the iteration interface and Base.eltype when possible. This is the minimal interface required to work with the rest of ParameterSchedulers.jl.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"It is strongly recommended that your schedule subtypes ParameterSchedulers.AbstractSchedule. This will define Base.iterate and several other pieces of the iteration interface for you.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"AbstractSchedule takes a single type parameter, IsFinite. Below are the possible values.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"AbstractSchedule{true}: use for finite schedules\nBase.IteratorSize is auto-implemented as Base.HasLength()\nBase.axes(s) is auto-implemented as 1:length(s)\nRequires Base.length to be implemented by you\nAbstractSchedule{false}: use for infinite schedules\nBase.IteratorSize is auto-implemented as Base.IsInfinite()\nBase.axes is auto-implemented as OneToInf()\nAbstractSchedule{missing}: use for schedules where infinite/finite is unknown\nBase.IteratorSize is auto-implemented as Base.SizeUnknown()\nBase.axes is auto-implemented as OneToInf()\nAbstractSchedule{T}: use for schedules where the length depends on T\nBase.IteratorSize is auto-implemented as Base.IteratorSize(T)","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"ParameterSchedulers.AbstractSchedule","category":"page"},{"location":"interface/#ParameterSchedulers.AbstractSchedule","page":"Schedule interface","title":"ParameterSchedulers.AbstractSchedule","text":"AbstractSchedule{IsFinite}\n\nInherit from this type to create a custom schedule. Type parameter IsFinite can take three values:\n\ntrue: for finite schedules\nfalse: for infinite schedules\nmissing: for higher-order schedules where the length is unknown            (similar to Base.SizeUnknown())\nT: a type T that indicates all iterator interface functions      should forward to this type\n\nRead the generic interface docs section for more.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Examples","page":"Schedule interface","title":"Examples","text":"","category":"section"},{"location":"interface/#Lambda-schedule","page":"Schedule interface","title":"Lambda schedule","text":"","category":"section"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"Below we implement Lambda to illustrate what is required for a custom schedule. Lambda simply wraps a function, f, and the schedule value at iteration t is f(t).","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"using ParameterSchedulers\nusing ParameterSchedulers: AbstractSchedule\n\nstruct Lambda{T} <: AbstractSchedule{missing}\n    f::T\nend","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"Next we implement the necessary interfaces. The easiest way to define (s::Lambda)(t), then rely on that to define the iteration behavior.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"(schedule::Lambda)(t) = schedule.f(t)\n\nBase.iterate(schedule::Lambda, t = 1) = schedule(t), t + 1\n\n# since the eltype is unknown, we indicate it\nBase.IteratorEltype(::Type{<:Lambda}) = Base.EltypeUnknown()","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"tip: Tip\nSometimes, it might be more efficient to define Base.iterate separately from s(t). See Step for an example what this might look like.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"You can also define optional parts of the iteration interface if you choose. They are not required for ParameterSchedulers.jl.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"Once you are done defining the above interfaces, you can start using Lambda like any other schedule. For example, below we create a Loop where the interval is defined as a Lambda","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"using UnicodePlots\n\ns = Loop(Lambda(log), 4)\nt = 1:10 |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"interface/#Decay-by-half","page":"Schedule interface","title":"Decay by half","text":"","category":"section"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"We will implement a Decay2 schedule that halves the parameter value every iteration. First, we define the struct.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"using ParameterSchedulers\nusing ParameterSchedulers: AbstractSchedule\n\n# we subtype AbstractSchedule{IsFinite} with IsFinite == false\n# this is because this is an infinite schedule\nstruct Decay2{T<:Number} <: AbstractSchedule{false}\n    λ::T\nend","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"After this, we can define the interface functions. Our decay function will be defined as g(t) = frac12^t - 1.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"(schedule::Decay2)(t) = schedule.λ / 2^(t - 1)","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"Now, we can use Decay2 schedule like any other decay schedule. Below, sequence two different Decay2 schedules.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"using UnicodePlots\n\ns = Sequence(Decay2(0.5) => 5, Decay2(0.2) => 5)\nt = 1:10 |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"interface/#A-square-wave-schedule","page":"Schedule interface","title":"A square wave schedule","text":"","category":"section"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"Now, we'll use the interface to implement a new cyclic schedule, Square, which implements a square wave.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"using ParameterSchedulers\nusing ParameterSchedulers: AbstractSchedule\n\nstruct Square{T<:Number, S<:Integer} <: AbstractSchedule{false}\n    λ0::T\n    λ1::T\n    period::S\nend","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"Now, we implement the interface. The cycle function, g(t), will return λ1 for the first period / 2 steps, then λ0 for the next.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"(schedule::Square{T})(t) where T =\n    (mod(t - 1, schedule.period) < schedule.period / 2) ? schedule.λ1 : schedule.λ0","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"Square is ready to use like any other schedule.","category":"page"},{"location":"interface/","page":"Schedule interface","title":"Schedule interface","text":"using UnicodePlots\n\ns = Square(0.2, 0.8, 4)\nt = 1:20 |> collect\nlineplot(t, s.(t); border = :none)","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"using ParameterSchedulers # hide","category":"page"},{"location":"tutorials/getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"All schedules types in ParameterSchedulers.jl behave as callable iterators. For example, we can call the simple exponential decay schedule (Exp) below at a specific iteration:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"s = Exp(start = 0.1, decay = 0.8)\nprintln(\"s(1): \", s(1))\nprintln(\"s(5): \", s(5))","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"info: Info\nThe iterations are unitless. So, if you index a schedule every epoch, then the s(i) is parameter value at epoch i.","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"We can also use the schedule in an iterable context like a for-loop:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"for (i, param) in enumerate(s)\n    (i > 10) && break\n    println(\"s($i): \", param)\nend","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"warning: Warning\nMany schedules such as Exp are infinite iterators, so iterating over them will result in an infinite loop. You can use Base.IteratorSize to check if a schedule has infinite length.","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"Notice that the value of s(1) and s(5) is unchanged even though we accessed the schedule once by calling them and again in the for-loop. This is because all schedules in ParameterSchedulers.jl are immutable. If you want a stateful (mutable) schedule, then you can use ParameterSchedulers.Stateful:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"using ParameterSchedulers: Stateful, next!\n\nstateful_s = Stateful(s)\nprintln(\"s: \", next!(stateful_s))\nprintln(\"s: \", next!(stateful_s))\nprintln(stateful_s)","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"We used ParameterSchedulers.next! to advance the stateful iterator. Notice that stateful_s stores a reference to s and the current iteration state (which is 3 since we advanced the iterator twice). We can reset the mutable iteration state too:","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"using ParameterSchedulers: reset!\n\nreset!(stateful_s)\nprintln(\"s: \", next!(stateful_s))","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"Also note that Stateful cannot be called (or iterated with Base.iterate):","category":"page"},{"location":"tutorials/getting-started/","page":"Getting started","title":"Getting started","text":"try\n    stateful_s(1)\ncatch e\n    println(e)\nend","category":"page"},{"location":"api/decay/#Decay-schedule-API-reference","page":"Decay schedule API reference","title":"Decay schedule API reference","text":"","category":"section"},{"location":"api/decay/","page":"Decay schedule API reference","title":"Decay schedule API reference","text":"Modules = [ParameterSchedulers]\nPages = [\"decay.jl\"]","category":"page"},{"location":"api/decay/#ParameterSchedulers.Exp","page":"Decay schedule API reference","title":"ParameterSchedulers.Exp","text":"Exp{T}(start, decay)\nExp(; start, decay)\n\nA exponential decay schedule at rate decay. The output conforms to\n\nstart * decay^{t - 1}\n\nArguments:\n\nstart: the base value\ndecay: the decay rate\n\n\n\n\n\n","category":"type"},{"location":"api/decay/#ParameterSchedulers.Inv","page":"Decay schedule API reference","title":"ParameterSchedulers.Inv","text":"Inv{T, S<:Integer}(start, decay, degree)\nInv(; start, decay, degree)\n\nA decay schedule that inversely decays with rate decay. The output conforms to\n\nstart / (1 + (t - 1) * decay)^degree\n\nArguments\n\nstart: the base value\ndecay: the decay rate\ndegree::Integer: the degree of decay\n\n\n\n\n\n","category":"type"},{"location":"api/decay/#ParameterSchedulers.Poly","page":"Decay schedule API reference","title":"ParameterSchedulers.Poly","text":"Poly{T, S<:Integer}(start, degree, max_iter)\nPoly(; start, degree, max_iter)\n\nA polynomial schedule decays with degree degree. The output conforms to\n\nstart / (1 - (t - 1) / max_iter)^degree\n\nArguments\n\nstart: the base value\ndegree::Integer: the degree of the polynomial\nmax_iter::Integer: the total number of iterations\n\n\n\n\n\n","category":"type"},{"location":"api/decay/#ParameterSchedulers.Step","page":"Decay schedule API reference","title":"ParameterSchedulers.Step","text":"Step{T, S<:Integer}(start, decay, step_sizes)\nStep(; start, decay, step_sizes)\n\nA step schedule decays exponentially by decay every step in step_sizes. The output conforms to\n\nstart * decay^{i - 1}\n\nwhere sum(step_sizes[1:(i - 1)]) < t <= sum(step_sizes[1:i])\n\nArguments\n\nstart: the starting value\ndecay: the decay rate\nstep_sizes::Union{<:Integer, <:Vector}: the step sizes\n\n\n\n\n\n","category":"type"},{"location":"tutorials/basic-schedules/#Basic-schedules","page":"Basic schedules","title":"Basic schedules","text":"","category":"section"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"While ParameterSchedulers.jl has some complex scheduling capability, its core is made of two kinds of basic schedules: decay schedules and cyclic schedules. Each kind of schedule conforms to a formula which is relevant for understanding the schedules behavior. Still, both types of schedules can be called and iterated like we saw in the getting started tutorial.","category":"page"},{"location":"tutorials/basic-schedules/#Decay-schedules","page":"Basic schedules","title":"Decay schedules","text":"","category":"section"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"using ParameterSchedulers # hide","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"A decay schedule is defined by the following formula:","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"s(t) = l times g(t)","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"where s(t) is the schedule output, l is the base (initial) value, and g(t) is the decay function. Typically, the decay function is expected to be bounded between 0 1, but this requirement is only suggested and not enforced.","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"For example, here is an exponential decay schedule:","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"expdecay(decay, t) = decay^(t - 1)\ns = Exp(start = 0.1, decay = 0.8)\nprintln(\"l g(1) == s(1): \", 0.1 * expdecay(0.8, 1) == s(1))","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"As you can see above, Exp is a type of decay schedule. Below is a list of all the decay schedules implemented, and the parameters and decay functions for each one.","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"Schedule Parameters Decay Function\nStep start, decay, step_sizes g(t) = textttdecay^i - 1 where sum_j = 1^i - 1 textttstep_sizes_j  t leq sum_j = 1^i textttstep_sizes_j\nExp start, decay g(t) = textttdecay^t - 1\nPoly start, degree, max_iter g(t) = dfrac1left(dfrac1 - (t - 1)textttmax_iterright)^textttdegree\nInv start, decay, degree g(t) = dfrac1left(1 + textttdecay times (t - 1) right)^textttdegree","category":"page"},{"location":"tutorials/basic-schedules/#Cyclic-schedules","page":"Basic schedules","title":"Cyclic schedules","text":"","category":"section"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"using ParameterSchedulers #hide","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"A cyclic schedule exhibits periodic behavior, and it is described by the following formula:","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"s(t) = l_0 - l_1 g(t) + min (l_0 l_1)","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"where s(t) is the schedule output, l_0 and l_1 are the range endpoints, and g(t) is the cycle function. Similar to the decay function, the cycle function is expected to be bounded between 0 1, but this requirement is only suggested and not enforced.","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"For example, here is triangular wave schedule:","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"tricycle(period, t) = (2 / π) * abs(asin(sin(π * (t - 1) / period)))\ns = Triangle(l0 = 0.1, l1 = 0.4, period = 2)\nprintln(\n    \"abs(l0 - l1) * g(1) + min(l0, l1) == s(1): \",\n    abs(0.1 - 0.4) * tricycle(2, 1) + min(0.1, 0.4) == s(1)\n)","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"Triangle (used in the above example) is a type of cyclic schedule. Below is a list of all the cyclic schedules implemented, and the parameters and cycle functions for each one.","category":"page"},{"location":"tutorials/basic-schedules/","page":"Basic schedules","title":"Basic schedules","text":"Schedule Parameters Cycle Function\nTriangle l0, l1, period g(t) = dfrac2pi left arcsin (sin (fracpi (t - 1)textperiod)) right\nTriangleDecay2 l0, l1, period g(t) = dfrac12^lfloor (t - 1)  textttperiod rfloor g_textttTriangle(t)\nTriangleExp l0, l1, period, decay g(t) = textttdecay^t - 1 g_textttTriangle(t)\nSin l0, l1, period g(t) = left sin left(fracpi (t - 1)textttperiod right) right\nSinDecay2 l0, l1, period g(t) = dfrac12^lfloor (t - 1)  textttperiod rfloor g_textttSin(t)\nSinExp l0, l1, period, decay g(t) = textttdecay^t - 1 g_textttSin(t)\nCosAnneal l0, l1, period, with restart = true g(t) = dfrac12 left(1 + cos left(fracpi  mathrmmod(t - 1 textttperiod)textttperiodright) right)\nCosAnneal l0, l1, period, with restart = false g(t) = dfrac12 left(1 + cos left(fracpi  (t - 1)textttperiodright) right)","category":"page"},{"location":"api/cyclic/#Cyclic-schedule-API-reference","page":"Cyclic schedule API reference","title":"Cyclic schedule API reference","text":"","category":"section"},{"location":"api/cyclic/","page":"Cyclic schedule API reference","title":"Cyclic schedule API reference","text":"Modules = [ParameterSchedulers]\nPages = [\"cyclic.jl\"]","category":"page"},{"location":"api/cyclic/#ParameterSchedulers.CosAnneal","page":"Cyclic schedule API reference","title":"ParameterSchedulers.CosAnneal","text":"CosAnneal(l0, l1, period, restart = true)\nCosAnneal(; l0, l1, period, restart = true)\n\nA cosine annealing schedule (see \"SGDR: Stochastic Gradient Descent with Warm Restarts\") The output conforms to\n\nt̂ = restart ? (t - 1) : mod(t - 1, period)\nabs(l0 - l1) * (1 + cos(π * t̂ / period)) / 2 + min(l0, l1)\n\nThis schedule is also referred to as \"cosine annealing (with warm restarts)\" in machine learning literature.\n\nArguments\n\nrange == abs(l0 - l1): the dynamic range (given by the endpoints)\noffset == min(l0, l1): the offset / minimum value\nperiod::Integer: the period\nrestart::Bool: use warm-restarts\n\n\n\n\n\n","category":"type"},{"location":"api/cyclic/#ParameterSchedulers.Sin","page":"Cyclic schedule API reference","title":"ParameterSchedulers.Sin","text":"Sin(l0, l1, period)\nSin(; l0, l1, period)\n\nA sine wave schedule with period. The output conforms to\n\nabs(l0 - l1) * abs(sin(π * (t - 1) / period)) + min(l0, l1)\n\nArguments\n\nrange == abs(l0 - l1): the dynamic range (given by the endpoints)\noffset == min(l0, l1): the offset / minimum value\nperiod::Integer: the period\n\n\n\n\n\n","category":"type"},{"location":"api/cyclic/#ParameterSchedulers.Triangle","page":"Cyclic schedule API reference","title":"ParameterSchedulers.Triangle","text":"Triangle{T, S<:Integer}(l0, l1, period)\nTriangle(; l0, l1, period)\n\nA triangle wave schedule with period. The output conforms to\n\nabs(l0 - l1) * (2 / π) * abs(asin(sin(π * (t - 1) / period))) + min(l0, l1)\n\nArguments\n\nrange == abs(l0 - l1): the dynamic range (given by the endpoints)\noffset == min(l0, l1): the offset / minimum value\nperiod::Integer: the period\n\n\n\n\n\n","category":"type"},{"location":"api/cyclic/#ParameterSchedulers.SinDecay2-Union{Tuple{T}, Tuple{T, Any, Any}} where T","page":"Cyclic schedule API reference","title":"ParameterSchedulers.SinDecay2","text":"SinDecay2(l0, l1, period)\nSinDecay2(; l0, l1, period)\n\nA sine wave schedule with period and half the amplitude each cycle. The output conforms to\n\nabs(l0 - l1) * Sin(t) / (2^floor((t - 1) / period)) + min(l0, l1)\n\nwhere Sin(t) is abs(sin(π * (t - 1) / period)) (see Sin).\n\nArguments\n\nrange == abs(l0 - l1): the dynamic range (given by the endpoints)\noffset == min(l0, l1): the offset / minimum value\nperiod::Integer: the period\n\n\n\n\n\n","category":"method"},{"location":"api/cyclic/#ParameterSchedulers.SinExp-NTuple{4, Any}","page":"Cyclic schedule API reference","title":"ParameterSchedulers.SinExp","text":"SinExp(l0, l1, period, decay)\nSinExp(; l0, l1, period, decay)\n\nA sine wave schedule with period and an exponentially decaying amplitude. The output conforms to\n\nabs(l0 - l1) * Sin(t) * γ^(t - 1) + min(l0, l1)\n\nwhere Sin(t) is abs(sin(π * (t - 1) / period)) (see Sin).\n\nArguments\n\nrange == abs(l0 - l1): the dynamic range (given by the endpoints)\noffset == min(l0, l1): the offset / minimum value\nperiod::Integer: the period\ndecay: the decay rate\n\n\n\n\n\n","category":"method"},{"location":"api/cyclic/#ParameterSchedulers.TriangleDecay2-Union{Tuple{T}, Tuple{T, Any, Any}} where T","page":"Cyclic schedule API reference","title":"ParameterSchedulers.TriangleDecay2","text":"TriangleDecay2{T, S<:Integer}(l0, l1, period)\nTriangleDecay2(; l0, l1, period)\n\nA triangle wave schedule with period and half the amplitude each cycle. The output conforms to\n\nabs(l0 - l1) * Triangle(t) / (2^floor((t - 1) / period)) + min(l0, l1)\n\nwhere Triangle(t) is (2 / π) * abs(asin(sin(π * (t - 1) / schedule.period))) (see Triangle).\n\nArguments\n\nrange == abs(l0 - l1): the dynamic range (given by the endpoints)\noffset == min(l0, l1): the offset / minimum value\nperiod::Integer: the period\n\n\n\n\n\n","category":"method"},{"location":"api/cyclic/#ParameterSchedulers.TriangleExp-NTuple{4, Any}","page":"Cyclic schedule API reference","title":"ParameterSchedulers.TriangleExp","text":"TriangleExp{T, S<:Integer}(l0, l1, period, decay)\nTriangleExp(; l0, l1, period, decay)\n\nA triangle wave schedule with period and an exponentially decaying amplitude. The output conforms to\n\nabs(l0 - l1) * Triangle(t) * decay^(t - 1) + min(l0, l1)\n\nwhere Triangle(t) is (2 / π) * abs(asin(sin(π * (t - 1) / schedule.period))) (see Triangle).\n\nArguments\n\nrange == abs(l0 - l1): the dynamic range (given by the endpoints)\noffset == min(l0, l1): the offset / minimum value\nperiod::Integer: the period\ndecay: the decay rate\n\n\n\n\n\n","category":"method"},{"location":"cheatsheet/#Schedule-cheatsheet-for-other-frameworks","page":"Schedule cheatsheet","title":"Schedule cheatsheet for other frameworks","text":"","category":"section"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"If you are coming from PyTorch or Tensorflow, the following table should help you find the corresponding schedule policy in ParameterSchedulers.jl.","category":"page"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"note: Note\nPyTorch typically wraps an optimizer as the first argument, but we ignore that functionality in the table. To wrap a Flux.jl optimizer with a schedule from the rightmost column, use ParameterSchedulers.Scheduler. The variable lr in the middle/rightmost column refers to the initial learning rate of the optimizer.","category":"page"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"PyTorch Tensorflow ParameterSchedulers.jl\nLambdaLR(_, lr_lambda) N/A lr_lambda\nMultiplicativeLR(_, lr_lambda) N/A N/A\nStepLR(_, step_size, gamma) ExponentialDecay(lr, step_size, gamma, True) Step(lr, gamma, step_size)\nMultiStepLR(_, milestones, gamma) N/A Step(lr, gamma, milestones)\nConstantLR(_, factor, total_iters) N/A Sequence(lr * factor => total_iters, lr => nepochs)\nLinearLR(_, start_factor, end_factor, total_iters) N/A Sequence(Triangle(lr * start_factor, lr * end_factor, 2 * total_iters) => total_iters, lr => nepochs)\nExponentialLR(_, gamma) ExponentialDecay(lr, 1, gamma, False) Exp(lr, gamma)\nN/A ExponentialDecay(lr, steps, gamma, False) Interpolator(Exp(lr, gamma), steps)\nCosineAnnealingLR(_, T_max, eta_min) CosineDecay(lr, T_max, eta_min) CosAnneal(lr, eta_min, T_0, false)\nCosineAnnealingRestarts(_, T_0, 1, eta_min) CosineDecayRestarts(lr, T_0, 1, 1, eta_min) CosAnneal(lr, eta_min, T_0)\nCosineAnnealingRestarts(_, T_0, T_mult, eta_min) CosineDecayRestarts(lr, T_0, T_mult, 1, alpha) See below\nN/A CosineDecayRestarts(lr, T_0, T_mult, m_mul, alpha) See below\nSequentialLR(_, schedulers, milestones) N/A Sequence(schedulers, milestones)\nReduceLROnPlateau(_, mode, factor, patience, threshold, 'abs', 0) N/A See below\nCyclicLR(_, base_lr, max_lr, step_size, step_size, 'triangular', _, None) N/A Triangle(base_lr, max_lr, step_size)\nCyclicLR(_, base_lr, max_lr, step_size, step_size, 'triangular2', _, None) N/A TriangleDecay2(base_lr, max_lr, step_size)\nCyclicLR(_, base_lr, max_lr, step_size, step_size, 'exp_range', gamma, None) N/A TriangleExp(base_lr, max_lr, step_size, gamma)\nCyclicLR(_, base_lr, max_lr, step_size, step_size, _, _, scale_fn) N/A See Arbitrary looping schedules\nN/A InverseTimeDecay(lr, 1, decay_rate, False) Inv(lr, decay_rate, 1)\nN/A InverseTimeDecay(lr, decay_step, decay_rate, False) Interpolator(Inv(lr, decay_rate, 1), decay_step)\nN/A PolynomialDecay(lr, decay_steps, 0, power, False) Poly(lr, power, decay_steps)","category":"page"},{"location":"cheatsheet/#Cosine-annealing-variants","page":"Schedule cheatsheet","title":"Cosine annealing variants","text":"","category":"section"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"In addition to the plain cosine annealing w/ warm restarts schedule, we may want to decay the peak learning rate or increase the period. Both can be done using ComposedSchedule or Sequence.","category":"page"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"Let's start with the simpler task: decaying the learning rate.","category":"page"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"# decay learning rate by m_mul\ns = ComposedSchedule(CosAnneal(range, offset, period),\n                     (Step(range, m_mul, period), offset, period))","category":"page"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"To increase the period by a fixed multiple, we should think of each period of the schedule as an individual schedule concatenated together. This is exactly what Sequence is except that there is no limit to the number of periods that we concatenate together. Fortunately, Sequence accepts Base.Generators. When combined with InfiniteArrays.jl, we can create an infinite sequence of individual schedules.","category":"page"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"using InfiniteArrays: OneToInf\n\n# increase period by factor t_mul\ne = Exp(period, t_mul)\ns = Sequence(CosAnneal(range, offset, e(t)) for t in OneToInf(),\n             e(t) for t in OneToInf())","category":"page"},{"location":"cheatsheet/#ReduceLROnPlateau-style-schedules","page":"Schedule cheatsheet","title":"ReduceLROnPlateau style schedules","text":"","category":"section"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"Unlike PyTorch, ParameterSchedulers.jl doesn't create a monolithic schedule to control dynamic schedules. Instead, ParameterSchedulers.Stateful has an advance keyword argument that can allow for arbitrary advancement of schedules based on a predicate function. When combined with Flux.plateau as the predicate, we get ReduceLROnPlateau.","category":"page"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"# the code below is written to match\n# ReduceLROnPlateau(_, 'max', factor, patience, threshold, 'abs', 0)\n# we also assume accuracy_func() is an accuracy metric that's already given for our model\n\n# this is done to match ReduceLROnPlateau\n# but it could be any schedule\ns = Exp(lr, factor)\npredicate = Flux.plateau(accuracy_func, patience; min_dist = threshold)\nParameterSchedulers.Stateful(s; advance = predicate)","category":"page"},{"location":"cheatsheet/","page":"Schedule cheatsheet","title":"Schedule cheatsheet","text":"Using this approach, we can be more flexible than PyTorch. You can use any schedule (not just exponential decay) and arbitrary predicates. Make sure to check out the Flux docmentation on \"patience helpers\" for more ways to customize the predicate (e.g. the 'min' mode for ReduceLROnPlateau).","category":"page"},{"location":"#ParameterSchedulers","page":"Home","title":"ParameterSchedulers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ParameterSchedulers.jl provides common machine learning (ML) schedulers for hyper-parameters. Though this package is framework agnostic, a convenient interface for pairing schedules with Flux.jl optimizers is available. Using this package with Flux is as simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Flux, ParameterSchedulers\nusing ParameterSchedulers: Scheduler\n\nopt = Scheduler(Momentum, Exp(start = 1e-2, decay = 0.8))","category":"page"},{"location":"#Available-Schedules","page":"Home","title":"Available Schedules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a table of the common schedules implemented, but ParameterSchedulers provides utilities for creating more exotic schedules as well. The higher order schedules should make it so that you will rarely need to write a schedule from scratch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can read this paper for more information on the schedules below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<table>\n<thead>\n<tr>\n    <th>Schedule</th>\n    <th>Description</th>\n    <th>Type</th>\n    <th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/decay.html#ParameterSchedulers.Step\"><code>Step&#40;; start, decay, step_sizes&#41;</code></a></p>\n</td>\n<td>\n<p>Exponential decay by <code>decay</code> every step in <code>step_sizes</code></p>\n</td>\n<td> Decay </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = Step(start = 1.0, decay = 0.8, step_sizes = [2, 3, 2]) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/decay.html#ParameterSchedulers.Exp\"><code>Exp&#40;start, decay&#41;</code></a></p>\n</td>\n<td>\n<p>Exponential decay by <code>decay</code> every iteration</p>\n</td>\n<td> Decay </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = Exp(start = 1.0, decay = 0.5) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/cyclic.html#ParameterSchedulers.CosAnneal\"><code>CosAnneal&#40;;l0, l1, period&#41;</code></a></p>\n</td>\n<td>\n<p><a href=\"https://arxiv.org/abs/1608.03983v5\">Cosine annealing</a></p>\n</td>\n<td> Cyclic </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = CosAnneal(l0 = 0.0, l1 = 1.0, period = 4) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/complex.html#ParameterSchedulers.OneCycle\"><code>OneCycle&#40;nsteps, maxval&#41;</code></a></p>\n</td>\n<td>\n<p><a href=\"https://arxiv.org/abs/1708.07120\">One cycle cosine</a></p>\n</td>\n<td> Complex </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = OneCycle(10, 1.0) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/cyclic.html#ParameterSchedulers.Triangle\"><code>Triangle&#40;l0, l1, period&#41;</code></a></p>\n</td>\n<td>\n<p><a href=\"https://en.wikipedia.org/wiki/Triangle_wave\">Triangle wave</a> function</p>\n</td>\n<td> Cyclic </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = Triangle(l0 = 0.0, l1 = 1.0, period = 2) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/cyclic.html#ParameterSchedulers.TriangleDecay2\"><code>TriangleDecay2&#40;l0, l1, period&#41;</code></a></p>\n</td>\n<td>\n<p><a href=\"https://en.wikipedia.org/wiki/Triangle_wave\">Triangle wave</a> function with half the amplitude every <code>period</code></p>\n</td>\n<td> Cyclic </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = TriangleDecay2(l0 = 0.0, l1 = 1.0, period = 2) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/cyclic.html#ParameterSchedulers.TriangleExp\"><code>TriangleExp&#40;l0, l1, period, decay&#41;</code></a></p>\n</td>\n<td>\n<p><a href=\"https://en.wikipedia.org/wiki/Triangle_wave\">Triangle wave</a> function with exponential amplitude decay at rate <code>decay</code></p>\n</td>\n<td> Cyclic </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = TriangleExp(l0 = 0.0, l1 = 1.0, period = 2, decay = 0.8) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/decay.html#ParameterSchedulers.Poly\"><code>Poly&#40;start, degree, max_iter&#41;</code></a></p>\n</td>\n<td>\n<p>Polynomial decay at degree <code>degree</code>.</p>\n</td>\n<td> Decay </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = Poly(start = 1.0, degree = 2, max_iter = t[end]) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/decay.html#ParameterSchedulers.Inv\"><code>Inv&#40;start, decay, degree&#41;</code></a></p>\n</td>\n<td>\n<p>Inverse decay at rate <code>&#40;1 &#43; t * decay&#41;^degree</code></p>\n</td>\n<td> Decay </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = Inv(start = 1.0, degree = 2, decay = 0.8) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/cyclic.html#ParameterSchedulers.Sin\"><code>Sin&#40;;l0, l1, period&#41;</code></a></p>\n</td>\n<td>\n<p>Sine function</p>\n</td>\n<td> Cyclic </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = Sin(l0 = 0.0, l1 = 1.0, period = 2) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/cyclic.html#ParameterSchedulers.SinDecay2\"><code>SinDecay2&#40;l0, l1, period&#41;</code></a></p>\n</td>\n<td>\n<p>Sine function with half the amplitude every <code>period</code></p>\n</td>\n<td> Cyclic </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = SinDecay2(l0 = 0.0, l1 = 1.0, period = 2) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n<tr><td>\n<p><a href=\"https://fluxml.ai/ParameterSchedulers.jl/api/cyclic.html#ParameterSchedulers.SinExp\"><code>SinExp&#40;l0, l1, period&#41;</code></a></p>\n</td>\n<td>\n<p>Sine function with exponential amplitude decay at rate <code>decay</code></p>\n</td>\n<td> Cyclic </td>\n<td style=\"text-align:center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnicodePlots, ParameterSchedulers # hide\nt = 1:10 |> collect # hide\ns = SinExp(l0 = 0.0, l1 = 1.0, period = 2, decay = 0.8) # hide\nlineplot(t, s.(t); width = 15, height = 3, border = :ascii, labels = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</td></tr>\n</tbody>\n</table>","category":"page"},{"location":"tutorials/optimizers/#Scheduling-optimizers","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"","category":"section"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"A schedule by itself is not helpful; we need to use the schedules to adjust parameters. In this tutorial, we will examine three ways to do just that–-iterating the schedule, using a stateful iterator, and using an scheduled optimizer. The final option is the preferred method for FluxML.","category":"page"},{"location":"tutorials/optimizers/#Iterating-during-training","page":"Scheduling optimizers","title":"Iterating during training","text":"","category":"section"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"Since every schedule is a standard iterator, we can insert it into a training loop by simply zipping up with another iterator. For example, the following code adjusts the learning rate of the optimizer before each batch of training.","category":"page"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"using Flux, ParameterSchedulers\nusing Optimisers: Descent, adjust!\n\ndata = [(Flux.rand32(4, 10), rand([-1, 1], 1, 10)) for _ in 1:3]\nm = Chain(Dense(4, 4, tanh), Dense(4, 1, tanh))\nopt = Descent()\nopt_st = Flux.setup(opt, m)\ns = Exp(start = 1e-1, decay = 0.2)\n\nfor (eta, (x, y)) in zip(s, data)\n    global opt_st, m\n    adjust!(opt_st, eta)\n    g = Flux.gradient(m -> Flux.mse(m(x), y), m)[1]\n    opt_st, m = Flux.update!(opt_st, m, g)\n    println(\"opt state: \", opt_st.layers[1].weight.rule)\nend","category":"page"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"We can also adjust the learning on an epoch basis instead. All that is required is to change what we zip our schedule with.","category":"page"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"nepochs = 6\ns = Step(start = 1e-1, decay = 0.2, step_sizes = [3, 2, 1])\nfor (eta, epoch) in zip(s, 1:nepochs)\n    global opt_st\n    adjust!(opt_st, eta)\n    for (i, (x, y)) in enumerate(data)\n        global m\n        g = Flux.gradient(m -> Flux.mse(m(x), y), m)[1]\n        opt_st, m = Flux.update!(opt_st, m, g)\n        println(\"epoch: $epoch, batch: $i, opt state: $(opt_st.layers[1].weight.rule)\")\n    end\nend","category":"page"},{"location":"tutorials/optimizers/#Stateful-iteration-with-training","page":"Scheduling optimizers","title":"Stateful iteration with training","text":"","category":"section"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"Sometimes zipping up the schedule with an iterator isn't sufficient. For example, we might want to advance the schedule with every batch but not be forced to restart each epoch. In such a situation with nested loops, it becomes useful to use ParameterSchedulers.Stateful which maintains its own iteration state. {cell=optimizers}","category":"page"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"nepochs = 3\ns = ParameterSchedulers.Stateful(Inv(start = 1e-1, decay = 0.2, degree = 2))\nfor epoch in 1:nepochs\n    for (i, (x, y)) in enumerate(data)\n        global opt_st, m\n        adjust!(opt_st, ParameterSchedulers.next!(s))\n        g = Flux.gradient(m -> Flux.mse(m(x), y), m)[1]\n        opt_st, m = Flux.update!(opt_st, m, g)\n        println(\"epoch: $epoch, batch: $i, opt state: $(opt_st.layers[1].weight.rule)\")\n    end\nend","category":"page"},{"location":"tutorials/optimizers/#Working-with-Flux-optimizers","page":"Scheduling optimizers","title":"Working with Flux optimizers","text":"","category":"section"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"While the approaches above can be helpful when dealing with fine-grained training loops, it is usually simpler to just use a ParameterSchedulers.Scheduler.","category":"page"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"using ParameterSchedulers: Scheduler\n\nnepochs = 3\ns = Inv(start = 1e-1, degree = 2, decay = 0.2)\nopt = Scheduler(Descent, s)\nopt_st = Flux.setup(opt, m)\nfor epoch in 1:nepochs\n    for (i, (x, y)) in enumerate(data)\n        global opt_st, m\n        sched_step = opt_st.layers[1].weight.state.t\n        println(\"epoch: $epoch, batch: $i, sched state: $sched_step\")\n        g = Flux.gradient(m -> Flux.mse(m(x), y), m)[1]\n        opt_st, m = Flux.update!(opt_st, m, g)\n    end\nend","category":"page"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"The scheduler, opt, can be used anywhere a Flux optimizer can. For example, it can be passed to Flux.train!:","category":"page"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"s = Inv(start = 1e-1, degree = 2, decay = 0.2)\nopt = Scheduler(Descent, s)\nopt_st = Flux.setup(opt, m)\nloss(m, x, y) = Flux.mse(m(x), y)\nfor epoch in 1:nepochs\n    sched_step = opt_st.layers[1].weight.state.t\n    println(\"epoch: $epoch, sched state: $sched_step\")\n    Flux.train!(loss, m, data, opt_st)\nend","category":"page"},{"location":"tutorials/optimizers/","page":"Scheduling optimizers","title":"Scheduling optimizers","text":"Finally, you might be interested in reading Interpolating schedules to see how to specify a schedule in terms of epochs but iterate it at the granularity of batches.","category":"page"}]
}
